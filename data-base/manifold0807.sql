/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.17 : Database - manifold_community
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`manifold_community` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `manifold_community`;

/*Table structure for table `answer_table` */

DROP TABLE IF EXISTS `answer_table`;

CREATE TABLE `answer_table` (
  `answer_id` bigint(64) NOT NULL AUTO_INCREMENT,
  `question_id` bigint(64) NOT NULL,
  `content` text NOT NULL,
  `uid` bigint(64) NOT NULL,
  `agree` bigint(64) DEFAULT '0',
  `disagree` bigint(64) DEFAULT '0',
  `read_times` bigint(64) DEFAULT '0',
  `reserve1` int(11) DEFAULT NULL,
  PRIMARY KEY (`answer_id`),
  KEY `uid` (`uid`),
  KEY `question_id` (`question_id`),
  CONSTRAINT `answer_table_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `user_table` (`uid`),
  CONSTRAINT `answer_table_ibfk_2` FOREIGN KEY (`question_id`) REFERENCES `question_table` (`question_id`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8;

/*Data for the table `answer_table` */

insert  into `answer_table`(`answer_id`,`question_id`,`content`,`uid`,`agree`,`disagree`,`read_times`,`reserve1`) values (3,10,'<p>我来回答</p><p><strong>测试回答</strong></p><p><i>斜体</i></p><blockquote><ol><li>测试引用1</li><li>测试引用2</li><li>测试引用3</li></ol></blockquote><p>测试图片</p><figure class=\"image\"><img src=\"/upload-files/images/pom.jpg\"><figcaption>插图1</figcaption></figure><p>&nbsp;</p><p>哈哈哈</p><p>搞完了</p>',17,0,0,0,NULL),(4,11,'<blockquote><p><strong>resultType和resultMap功能类似&nbsp; ，都是返回对象信息&nbsp; ，但是resultMap要更强大一些 ，可自定义。因为resultMap要配置一下，表和类的一一对应关系，所以说就算你的字段名和你的实体类的属性名不一样也没关系，都会给你映射出来，但是，resultType就比较鸡肋了，必须字段名一样，比如说 cId和c_id 这种的都不能映射 。下面介绍几个常用的映射关系：</strong></p></blockquote>',16,0,0,0,NULL),(5,13,'<blockquote><p><i>配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</i></p></blockquote><p><i>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</i></p>',16,0,0,0,NULL),(6,14,'<blockquote><p>骗子，你妈买菜必涨价，超级加倍</p></blockquote>',16,0,0,0,NULL),(7,11,'<h2><strong>resultType（</strong>自动配置<strong>）</strong></h2><p>resultType可以把查询结果封装到pojo类型中，但必须pojo类的属性名和查询到的数据库表的字段名一致。 如果sql查询到的字段与pojo的属性名不一致，则需要使用resultMap将字段名和属性名对应起来，进行手动配置封装，将结果映射到pojo中,如下介绍resultMap</p><p>&nbsp;</p><h2><strong>resultMap（手动配置）</strong></h2><p>resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询</p><p>&lt;resultMap&gt;标签写在mapper.xml中，有程序员控制sql查询结果与实体类的映射关系</p><p>注：使用resultMap标签时，&lt;select&gt;标签不写resultType属性，而是使用resultMap属性引用&lt;resultMap&gt;标签</p>',17,0,0,0,NULL),(8,13,'<p><i><strong>适配器模式（Adapter Pattern）</strong></i>，把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。又称为转换器模式、变压器模式、包装（Wrapper）模式（把已有的一些类包装起来，使之能有满足需要的接口）。<br>存在两种适配器模式：<br><strong>(1) 对象适配器模式</strong>——在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。<br><strong>(2) 类适配器模式</strong>——这种适配器模式下，适配器继承自已实现的类。<br>无论哪种适配器，它的宗旨都是：保留现有类所提供的服务，向客户提供接口，以满足客户的期望。即在不改变原有系统的基础上，提供新的接口服务。</p><figure class=\"image\"><img src=\"/upload-files/images/lubenweiNBavatar.jpg\"></figure><p><br><br>推荐你一本设计模式方面的权威书籍：郑阿奇 主编的《软件秘笈-设计模式那点事》。里面讲解很到位，实例通俗易懂，看了收获很大！</p>',17,0,0,0,NULL),(9,14,'<p><strong>我卢本伟真的没有开挂!</strong></p><p><i>给阿姨倒一杯卡布奇诺</i></p><figure class=\"image\"><img src=\"/upload-files/images/lubenweiNBavatar.jpg\"></figure>',17,0,0,0,NULL),(10,15,'<ul><li>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时候被指定为一个特定的类型，声明之后不能改变。<br>&nbsp;</li><li>引用数据类型包括：类（对象）、接口、数组。<br>&nbsp;</li><li>所有引用类型默认值都是null.<br>&nbsp;</li><li>一个引用变量可以用于引用任何与之兼容的类型</li></ul>',16,0,0,0,NULL),(11,16,'<p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p><p>GET请求只能进行url编码，而POST支持多种编码方式。</p><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p><p>GET和POST说到底就是HTTP的两种发送请求的方式，HTTP是基于TCP/IP在万维网中通信的协议</p><p>TCP是汽车，HTTP是运输规则,不同的浏览器（发送请求）和服务器（接受请求）是不同的运输公司,GET和POST本质上是TCP链接，由于HTTP的规定以及各运输公司的显示，导致他们的在应用过程中有不同的呈现</p><p>还有一个重大区别就是GET产生一个数据包，POST产生两个数据包，对于GET方式的请求，浏览器会将header和data一并发送过去，服务器相应200（返回数据）</p><p>对于POST请求，浏览器会先将header发送，服务器相应100（continue），在发送data，服务器相应200（返回数据）</p>',16,0,0,0,NULL),(12,17,'<p>1.以自动增长ID为主键,以MySQL为例</p><p>select * from some_<i>table order by id limit number_a,number</i>_b</p><p>2.以Oracle为例</p><p>select&nbsp;<i> from (select rownum r,</i>* from some_<i>table where r&lt;number_a) where r&gt;number</i>_b</p>',16,0,0,0,NULL),(13,18,'<p>DOM解析和SAX解析</p><p>DOM解析是树状结构，解析前需要加载整个结构，处理大型文件时效率较低，因为占的内存很多。适合于对XML的随机访问</p><p>SAX是事件驱动类型，不需要一次性整个装载文件，顺序读取XML文件，每遇到文件开头或者文件结尾，标签开头或者标签结尾 ，就会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问</p>',16,0,0,0,NULL),(14,19,'<p>Spring能有效的讲javaEE各层，控制层，服务层，持久层以松耦的方式组合在一起，各层的调用完全面向接口，所以重构代码的时候可以减少很多工作。</p><p>而以上都依赖于Spring的依赖注入的机制，当某个对象需要调用另一个对象时，传统的方式就是构造另一个对象的实例，再调用其中的方法，但在spring中这种构造实例的方法并不需要开发者自己创建，一般都是由IOC容器创建，再掉，引用注入者。</p><p>比如在原始社会，如果自己需要一把斧子，那么就需要自己自己去做，调用者自己创建被调用者</p><p>进入工业社会，如果我需要一把斧子，只需要去工厂或者生产者那里去拿就行了，我不需要知道这个斧子的具体做法，一般工厂模式</p><p>进入共产主义社会，需要斧子也不用去工厂找了，直接在家里说一声就行了，这个就叫做依赖注入</p>',16,0,0,0,NULL),(15,20,'<p>java data object,Java对象持久化的新的规范，也是一个用于存储某种数据仓库的对象的API，对开发人员来说，就不需要再编写冗余的JDBC代码从而将更多的精力投入到业务代码和逻辑上</p>',16,0,0,0,NULL),(16,22,'<p>因为五五开可以用20欢乐豆赢到500万欢乐豆</p>',18,0,0,0,NULL),(17,23,'<p>我经历过最经典的</p><p>那是一个下雨的晚上，兴许是雨的作用，大家都呆在家中。</p><p>我楼上，住着一对小夫妻，女的长得娇小可人，男的刚从部队退伍回来，时不时在我们当中露露股二头肌。</p><p>下雨天，是最适合睡觉的日子。</p><p>那天，约么晚上10点这样，早早就上床睡了。</p><p>矇矇中，被一阵阵有节奏的木头敲墙壁的声音给震醒了。</p><p>结果睡不着了，索性就睁开眼睛，竖起耳朵细细地在听。</p><p>眼睛瞟了一眼桌上的钟：“考，都要十二点了，还不睡！”</p><p>咚壁的敲击声依然是那么有节奏。。。。。。</p><p>结果，在听着有节奏的敲击声中，不知不觉又迷迷胡胡地睡着了。</p><p>突然，从梦中被惊醒了，</p><p>只听见楼上，好象在用锤子大力地敲着床板。</p><p>一看钟，妈妈的，都2点了，还让不让人睡，真够力的。</p><p>结果，第二天早上，偶遇到那个男的，问他昨晚怎么回事。</p><p>那男的说：不好意思，用力过猛，昨晚床塌了。！！</p><p>当时把我我乐得。。。。。整个公司的人笑了他一年！</p><p><br><br>&nbsp;</p>',18,0,0,0,NULL),(18,24,'<p><strong>1、什么是Redis？简述它的优缺点？</strong></p><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。</p><p>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。</p><p>另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><p><strong>2、Redis相比memcached有哪些优势？</strong></p><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>(2) redis的速度比memcached快很多</p><p>(3) redis可以持久化其数据</p><p><strong>3、Redis支持哪几种数据类型？</strong></p><p>String、List、Set、Sorted Set、hashes</p><p><strong>4、Redis主要消耗什么物理资源？</strong></p><p>内存。</p><p><strong>5、Redis的全称是什么？</strong></p><p>Remote Dictionary Server。</p><p><strong>6、Redis有哪几种数据淘汰策略？</strong></p><p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</p><p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p><p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p><p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p><p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p><p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p><p><strong>7、Redis官方为什么不提供Windows版本？</strong></p><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p><p><strong>8、一个字符串类型的值能存储最大容量是多少？</strong></p><p>512M</p><p><strong>9、为什么Redis需要把所有数据放到内存中？</strong></p><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。</p><p>所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。</p><p>在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><p><strong>10、Redis集群方案应该怎么做？都有哪些方案？</strong></p><p>1.codis。</p><p>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。</p><p>2.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p><p>4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p><p><strong>11、Redis集群方案什么情况下会导致整个集群不可用？</strong></p><p>有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p><p><strong>12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</strong></p><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><p><strong>13、Redis有哪些适合的场景？</strong></p><p>（1）会话缓存（Session Cache）</p><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><p>（2）全页缓存（FPC）</p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p><p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p><p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p>（3）队列</p><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p><p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><p><strong>（4）排行榜/计数器</strong></p><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。</p><p>所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORES</p><p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><p><strong>（5）发布/订阅</strong></p><p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！</p><p><strong>14、Redis支持的Java客户端都有哪些？官方推荐用哪个？</strong></p><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><p><strong>15、Redis和Redisson有什么关系？</strong></p><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic2.zhimg.com/80/v2-b0d69c9174d18349c6e04d706398429d_hd.jpg\"></figure><p><br>&nbsp;</p><p><strong>16、Jedis与Redisson对比有什么优缺点？</strong></p><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</p><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><p><strong>17、Redis如何设置密码及验证密码？</strong></p><p>设置密码：config set requirepass 123456</p><p>授权密码：auth 123456</p><p><strong>18、说说Redis哈希槽的概念？</strong></p><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p><p><strong>19、Redis集群的主从复制模型是怎样的？</strong></p><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p><p><strong>20、Redis集群会有写操作丢失吗？为什么？</strong></p><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><p><strong>21、Redis集群之间是如何复制的？</strong></p><p>异步复制</p><p><strong>22、Redis集群最大节点个数是多少？</strong></p><p>16384个。</p><p><strong>23、Redis集群如何选择数据库？</strong></p><p>Redis集群目前无法做数据库选择，默认在0数据库。</p><p><strong>24、怎么测试Redis的连通性？</strong></p><p>ping</p><p><strong>25、Redis中的管道有什么用？</strong></p><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p><p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p><p><strong>26、怎么理解Redis事务？</strong></p><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p><strong>27、Redis事务相关的命令有哪几个？</strong></p><p>MULTI、EXEC、DISCARD、WATCH</p><p><strong>28、Redis key的过期时间和永久有效分别怎么设置？</strong></p><p>EXPIRE和PERSIST命令。</p><p><strong>29、Redis如何做内存优化？</strong></p><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p><p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p><p><strong>30、Redis回收进程如何工作的？</strong></p><p>一个客户端运行了新的命令，添加了新的数据。</p><p>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</p><p>一个新的命令被执行，等等。</p><p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p><p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>',18,0,0,0,NULL),(19,25,'<h2>前言</h2><p><br>&nbsp;</p><p>本文主要受众为开发人员,所以不涉及到MySQL的服务部署等操作,且内容较多,大家准备好耐心和瓜子矿泉水.</p><p><br>前一阵系统的学习了一下MySQL,也有一些实际操作经验,偶然看到一篇和MySQL相关的面试文章,发现其中的一些问题自己也回答不好,虽然知识点大部分都知道,但是无法将知识串联起来.</p><p><br>因此决定搞一个MySQL灵魂100问,试着用回答问题的方式,让自己对知识点的理解更加深入一点.</p><h2>索引相关</h2><p><br><strong>1. 什么是索引?</strong><br>索引是一种数据结构,可以帮助我们快速的进行数据的查找.</p><p><br><strong>2. 索引是个什么样的数据结构呢?</strong></p><p><br>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.</p><p><br><strong>3. Hash索引和B+树所有有什么区别或者说优劣呢?</strong></p><p><br>首先要知道Hash索引和B+树索引的底层实现原理:</p><p><br>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.<br>那么可以看出他们有以下的不同:<br>&nbsp;</p><ul><li>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</li></ul><p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.<br>&nbsp;</p><ul><li>hash索引不支持使用索引进行排序,原理同上.<br>&nbsp;</li><li>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.<strong>AAAA</strong>和<strong>AAAAB</strong>的索引没有相关性.<br>&nbsp;</li><li>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.<br>&nbsp;</li><li>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.<br>&nbsp;</li></ul><p>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</p><p><br><strong>4. 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?</strong></p><p><br>在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.</p><p><br>当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.</p><p><br><strong>5. 非聚簇索引一定会回表查询吗?</strong></p><p><br>不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.</p><p>举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age &lt; 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.</p><p><br><strong>6. 在建立索引的时候,都有哪些需要考虑的因素呢?</strong></p><p><br>建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.</p><p><br><strong>7. 联合索引是什么?为什么需要注意联合索引中的顺序?</strong></p><p><br>MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.<br>具体原因为:</p><p><br>MySQL使用索引时需要索引有序,假设现在建立了\"name,age,school\"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.</p><p><br>当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.</p><p><br><strong>8. 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?</strong></p><p><br>MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.</p><p><br><strong>9. 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?</strong><br>&nbsp;</p><ul><li>使用不等于查询,</li><li>列参与了数学运算或者函数</li><li>在字符串like时左边是通配符.类似于\'%aaa\'.</li><li>当mysql分析全表扫描比使用索引快的时候不使用索引.</li><li>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.</li></ul><p>以上情况,MySQL无法使用索引.</p><h2><br>事务相关</h2><p><br><strong>1. 什么是事务?</strong></p><p><br>理解什么是事务最经典的就是转账的栗子,相信大家也都了解,这里就不再说一边了.<br>事务是一系列的操作,他们要符合ACID特性.最常见的理解就是:事务中的操作要么全部成功,要么全部失败.但是只是这样还不够的.</p><p><br><strong>2. ACID是什么?可以详细说一下吗?</strong></p><p><br>A=Atomicity<br>原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.<br>C=Consistency<br>系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.<br>I=Isolation<br>隔离性: 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.<br>D=Durability<br>持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.</p><p><br><strong>3. 同时有多个事务在进行会怎么样呢?</strong></p><p><br>多事务的并发进行一般会造成以下几个问题:<br>&nbsp;</p><ul><li>脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.</li><li>不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.</li><li>幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成\"幻觉\".</li></ul><p><strong>4. 怎么解决这些问题呢?MySQL的事务隔离级别了解吗?</strong></p><p><br>MySQL的四种隔离级别如下:<br>&nbsp;</p><ul><li>未提交读(READ UNCOMMITTED)</li></ul><p>这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).<br>这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.<br>&nbsp;</p><ul><li>已提交读(READ COMMITTED)</li></ul><p>其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.<br>&nbsp;</p><ul><li>REPEATABLE READ(可重复读)</li></ul><p>可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取id&gt; 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.<br>&nbsp;</p><ul><li>SERIALIZABLE(可串行化)</li></ul><p>这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.</p><p><br><strong>5. Innodb使用的是哪种隔离级别呢?</strong></p><p><br>InnoDB默认使用的是可重复读隔离级别.</p><p><br><strong>6. 对MySQL的锁了解吗?</strong></p><p><br>当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.<br>就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.</p><p><br><strong>7. MySQL都有哪些锁呢?像上面那样子进行锁定岂不是有点阻碍并发效率了?</strong></p><p><br>从锁的类别上来讲,有共享锁和排他锁.<br>共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.<br>排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.<br>用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.<br>锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.<br>他们的加锁开销从大大小,并发能力也是从大到小.</p><h2><br>表结构设计</h2><p><br><strong>1. 为什么要尽量设定一个主键?</strong></p><p><br>主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.</p><p><br><strong>2. 主键使用自增ID还是UUID?</strong></p><p><br>推荐使用自增ID,不要使用UUID.<br>因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.<br>总之,在数据量大一些的情况下,用自增主键性能会好一些.<br><i>图片来源于《高性能MySQL》: 其中默认后缀为使用自增ID,_uuid为使用UUID为主键的测试,测试了插入100w行和300w行的性能.</i><br><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic4.zhimg.com/80/v2-c428528b5f35720c9f88bba5e558c337_hd.jpg\"></figure><p><br>关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.</p><p>If you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index.</p><p><br>&nbsp;</p><p>NULL columns require additional space in the rowto record whether their values \nare NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up \nto the nearest byte.</p><p>null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.</p><p><br><strong>4. 如果要存储用户的密码散列,应该使用什么字段进行存储?</strong></p><p><br>密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率.</p><h2><br>存储引擎相关</h2><p><br><strong>1. MySQL支持哪些存储引擎?</strong></p><p><br>MySQL支持多种存储引擎,比如InnoDB,MyISAM,Memory,Archive等等.在大多数的情况下,直接选择使用InnoDB引擎都是最合适的,InnoDB也是MySQL的默认存储引擎.<br>&nbsp;</p><ol><li>InnoDB和MyISAM有什么区别?</li></ol><ul><li>InnoDB支持事物，而MyISAM不支持事物</li><li>InnoDB支持行级锁，而MyISAM支持表级锁</li><li>InnoDB支持MVCC, 而MyISAM不支持</li><li>InnoDB支持外键，而MyISAM不支持</li><li>InnoDB不支持全文索引，而MyISAM支持。</li></ul><h2>零散问题</h2><p><br><strong>1. MySQL中的varchar和char有什么区别.</strong></p><p><br>char是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用10个字符,而varchar是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.</p><p><br>在检索效率上来讲,char &gt; varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则应该尽量使用varchar.例如存储用户MD5加密后的密码,则应该使用char.</p><p><br><strong>2. varchar(10)和int(10)代表什么含义?</strong></p><p><br>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.</p><p><br><strong>3. MySQL的binlog有有几种录入格式?分别有什么区别?</strong></p><p><br>有三种格式,statement,row和mixed.<br>&nbsp;</p><ul><li>statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.</li><li>row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.</li><li>mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.</li></ul><p>此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.</p><p><br><strong>4. 超大分页怎么处理?</strong></p><p><br>超大的分页一般从两个方向上来解决.<br>&nbsp;</p><ul><li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li><li>从需求的角度减少这种请求....主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p><br>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.<br><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic3.zhimg.com/80/v2-a4e30f3ce60ec68cc3b856a17ea67bbe_hd.jpg\"></figure><p><br><strong>5. 关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?</strong></p><p><br>在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.</p><p><br>慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?</p><p><br>所以优化也是针对这三个方向来的,<br>&nbsp;</p><ul><li>首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.<br>&nbsp;</li><li>分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.<br>&nbsp;</li><li>如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.<br>&nbsp;</li></ul><p><strong>6. 上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗?</strong></p><p><br>横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的. 假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.</p><p><br>纵向分表是按列分表.假设我们现在有一张文章表.包含字段id-摘要-内容.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要,当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.我们可以将上面的表分为两张.id-摘要,id-内容.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.</p><p><br>当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.</p><p><br><strong>7. 什么是存储过程？有哪些优缺点？</strong></p><p><br>存储过程是一些预编译的SQL语句。 1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</p><p><br>但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.</p><p><br><strong>8. 说一说三个范式</strong></p><p><br>第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.</p><p><br>在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.</p><p><br><strong>9. MyBatis中的#和$有什么区别?</strong></p><p><br>乱入了一个奇怪的问题.....我只是想单独记录一下这个问题,因为出现频率太高了.<br># 会将传入的内容当做字符串,而$会直接将传入值拼接在sql语句中.<br>所以#可以在一定程度上预防sql注入攻击.</p>',18,0,0,0,NULL),(20,26,'<p>HTTP协议本身是无状态的，为了保存会话信息，浏览器Cookie通过SessionID标识会话请求，服务器以SessionID为key来存储会话信息。在单实例应用中，可以考虑应用进程自身存储，随着应用体量的增长，需要横向扩容，多实例session共享问题随之而来。</p><p>Spring Session就是为了解决多进程session共享的问题，本文将介绍怎么使用Spring Session，以及Spring Session工作原理。</p><h3>1、引入背景</h3><p>应用部署在Tomcat时，session是由Tomcat内存维护，如果应用部署多个实例，session就不能共享。Spring Session就是解决为了解决分布式场景中的session共享问题。</p><h3>2、使用方法</h3><p>Spring Session支持存储在Hazelcast 、Redis、MongoDB、关系型数据库，本文主要讨论session存储在Redis。</p><p>web.xml配置：</p><p>&lt;!-- spring session --&gt;\n &nbsp;&lt;filter&gt;\n &nbsp; &nbsp;&lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;\n &nbsp; &nbsp;&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;\n &nbsp;&lt;/filter&gt;\n &nbsp;&lt;filter-mapping&gt;\n &nbsp; &nbsp;&lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;\n &nbsp; &nbsp;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n &nbsp;&lt;/filter-mapping&gt;</p><p>Spring 主要配置：</p><p>&lt;!--创建了一个RedisConnectionFactory，它将Spring会话连接到Redis服务器--&gt;\n &nbsp; &nbsp;&lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt;\n &nbsp; &nbsp; &nbsp; &nbsp;&lt;!--配置Redis连接池 ，可以不配置，使用默认就行！--&gt;\n &nbsp; &nbsp; &nbsp; &nbsp;p:poolConfig-ref=\"jedisPoolConfig\"\n &nbsp; &nbsp;&lt;/bean&gt;\n \n &nbsp; &nbsp;&lt;!--创建一个Spring Bean的名称springSessionRepositoryFilter实现过滤器--&gt;\n &nbsp; &nbsp;&lt;bean class=\"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration\"&gt;\n &nbsp; &nbsp; &nbsp; &nbsp;&lt;!--默认session时效30分钟--&gt;\n &nbsp; &nbsp; &nbsp; &nbsp;&lt;property name=\"maxInactiveIntervalInSeconds\" value=\"60\" /&gt;\n &nbsp; &nbsp;&lt;/bean&gt;</p><h3>3、工作流程</h3><p>Tomcat web.xml解析步骤：</p><p>contextInitialized(ServletContextEvent arg0); <i>// Listener\n</i>init(FilterConfig filterConfig); <i>// Filter\n</i>init(ServletConfig config); // Servlet</p><p>初始化顺序：Listener &gt; Filter &gt; Servlet。</p><p><strong>1) 通过 Tomcat 的 listener 把SessionRepositoryFilter加载到Spring容器中。</strong></p><p>上一小节Spring配置文件里面声明了RedisHttpSessionConfiguration，正是在其父类SpringHttpSessionConfiguration中生成了SessionRepositoryFilter：</p><p>@Bean\npublic &lt;S extends ExpiringSession&gt; SessionRepositoryFilter&lt;? extends ExpiringSession&gt; springSessionRepositoryFilter(\n &nbsp; &nbsp; &nbsp; &nbsp;SessionRepository&lt;S&gt; sessionRepository) {\n &nbsp; &nbsp;......\n &nbsp; &nbsp;return sessionRepositoryFilter;\n}</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-ed782a249f3b98f0ab3c8db434e86c8c_hd.jpg\"></figure><p><br>&nbsp;</p><p>RedisHttpSessionConfiguration类继承关系</p><p><strong>2) filter初始化</strong></p><p>web.xml里面配置的filter是DelegatingFilterProxy。</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic4.zhimg.com/80/v2-48e665c9195824cc17a93a071832b2f3_hd.jpg\"></figure><p><br>&nbsp;</p><p>DelegatingFilterProxy类继承关系</p><p>DelegatingFilterProxy初始化入口在其父类GenericFilterBean中：</p><p>public final void init(FilterConfig filterConfig) throws ServletException {\n &nbsp; &nbsp; &nbsp; &nbsp;......\n &nbsp; &nbsp; &nbsp; &nbsp;<i>// Let subclasses do whatever initialization they like.\n</i> &nbsp; &nbsp; &nbsp; &nbsp;initFilterBean();\n &nbsp; &nbsp; &nbsp; &nbsp;......\n &nbsp; &nbsp;}</p><p>DelegatingFilterProxy去Spring容器取第1步初始化好的springSessionRepositoryFilter：</p><p>protected void initFilterBean() throws ServletException {\n &nbsp; &nbsp; &nbsp; &nbsp;synchronized (this.delegateMonitor) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (this.delegate == null) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i>// If no target bean name specified, use filter name.\n</i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (this.targetBeanName == null) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i>//targetBeanName 为springSessionRepositoryFilter\n</i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.targetBeanName = getFilterName();\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WebApplicationContext wac = findWebApplicationContext();\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (wac != null) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.delegate = initDelegate(wac);\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp;}</p><p>至此 sessionRepositoryFilter 初始化完成，DelegatingFilterProxy 实际代理了SessionRepositoryFilter。</p><p>SessionRepositoryFilter 工作核心流程：</p><p>protected void doFilterInternal(HttpServletRequest request,\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response, FilterChain filterChain)\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throws ServletException, IOException {\n &nbsp; &nbsp; &nbsp; request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);\n &nbsp; &nbsp; &nbsp;&nbsp;<i>//包装了HttpServletRequest，覆写了HttpServletRequest中 getSession(boolean create)方法\n</i> &nbsp; &nbsp; &nbsp; SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryRequestWrapper(\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; request, response, this.servletContext);\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ......\n &nbsp; &nbsp; &nbsp; try {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filterChain.doFilter(strategyRequest, strategyResponse);\n &nbsp; &nbsp; &nbsp; }\n &nbsp; &nbsp; &nbsp; finally {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<i>//保证session持久化\n</i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wrappedRequest.commitSession();\n &nbsp; &nbsp; &nbsp; }\n &nbsp; }</p><h3>4、缓存机制</h3><p>每一个session，Redis实际缓存的数据如下：</p><blockquote><p>spring:session:sessions:1b8b2340-da25-4ca6-864c-4af28f033327<br>spring:session:sessions:expires:1b8b2340-da25-4ca6-864c-4af28f033327<br>spring:session:expirations:1557389100000</p></blockquote><p>spring:session:sessions为hash结构，存储Spring Session的主要内容：</p><p>hgetall spring:session:sessions:1b8b2340-da25-4ca6-864c-4af28f033327\n 1) \"creationTime\"\n 2) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01j\\x9b\\x83\\x9d\\xfd\"\n 3) \"maxInactiveInterval\"\n 4) \"\\xac\\xed\\x00\\x05sr\\x00\\x11java.lang.Integer\\x12\\xe2\\xa0\\xa4\\xf7\\x81\\x878\\x02\\x00\\x01I\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\a\\b\"\n 5) \"lastAccessedTime\"\n 6) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01j\\x9b\\x83\\x9d\\xfd\"</p><p>spring:session:sessions:expires 为 string 结构，存储一个空值。</p><p>spring:session:expirations为set结构，存储1557389100000 时间点过期的spring:session:sessions:expires键值：</p><p>smembers spring:session:expirations:1557389100000\n1) \"\\xac\\xed\\x00\\x05t\\x00,expires:1b8b2340-da25-4ca6-864c-4af28f033327\"</p><p>RedisSessionExpirationPolicy，三个键值生成流程：</p><p>public void onExpirationUpdated(Long originalExpirationTimeInMilli,\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ExpiringSession session) {\n &nbsp; &nbsp; &nbsp; &nbsp;String keyToExpire = \"expires:\" + session.getId();\n &nbsp; &nbsp; &nbsp; &nbsp;long toExpire = roundUpToNextMinute(expiresInMillis(session));\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;......\n &nbsp; &nbsp; &nbsp; &nbsp;<i>//把spring:session:sessions:expires加入到spring:session:expirations开头的key里面\n</i> &nbsp; &nbsp; &nbsp; &nbsp;String expireKey = getExpirationKey(toExpire);\n &nbsp; &nbsp; &nbsp; &nbsp;BoundSetOperations&lt;Object, Object&gt; expireOperations = this.redis\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.boundSetOps(expireKey);\n &nbsp; &nbsp; &nbsp; &nbsp;expireOperations.add(keyToExpire);\n \n &nbsp; &nbsp; &nbsp; &nbsp;long fiveMinutesAfterExpires = sessionExpireInSeconds\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+ TimeUnit.MINUTES.toSeconds(5);\n &nbsp; &nbsp; &nbsp; &nbsp;<i>//spring:session:expirations开头的key过期时间为xml配置的时间后五分钟\n</i> &nbsp; &nbsp; &nbsp; &nbsp;expireOperations.expire(fiveMinutesAfterExpires, TimeUnit.SECONDS);\n &nbsp; &nbsp; &nbsp; &nbsp;if (sessionExpireInSeconds == 0) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.redis.delete(sessionKey);\n &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp; &nbsp; &nbsp;else {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i>//spring:session:sessions:expires开头的key过期时间为xml配置的时间\n</i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.redis.boundValueOps(sessionKey).append(\"\");\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.redis.boundValueOps(sessionKey).expire(sessionExpireInSeconds,\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TimeUnit.SECONDS);\n &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp; &nbsp; &nbsp;<i>//spring:session:sessions开头的key过期时间为xml配置的时间后五分钟\n</i> &nbsp; &nbsp; &nbsp; &nbsp;this.redis.boundHashOps(getSessionKey(session.getId()))\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.expire(fiveMinutesAfterExpires, TimeUnit.SECONDS);\n &nbsp; &nbsp;}</p><p>Redis过期键有三种删除策略，分别是定时删除，惰性删除，定期删除。</p><ol><li>定时删除：通过维护一个定时器，过期马上删除，是最有效的，但是也是最浪费cpu时间的。</li><li>惰性删除：程序在取出键时才判断它是否过期，过期才删除，这个方法对cpu时间友好，对内存不友好。</li><li>定期删除：每隔一定时间执行一次删除过期键的操作，并限制每次删除操作的执行时长和频率，是一种折中。</li></ol><p>Redis采用了惰性删除和定期删除的策略。由此可见依赖 Redis 的过期策略实时删除过期key是不可靠的。</p><p>另外一方面，业务可能会在Spring Session过期后做业务逻辑处理，同时需要session里面的信息，如果只有一个 spring:session:sessions键值，那么Redis删除就删除了，业务没法获取session信息。</p><p>spring:session:expirations键中存储了spring:session:sessions:expires键，而spring:session:sessions:expires键过期五分钟早于spring:session:expirations键和spring:session:sessions键（实际Spring Session对于过期事件处理订阅的spring:session:sessions:expires键，下一节会具体讲），这样在订阅到过期事件时还能获取spring:session:sessions键值。</p><p>如果通过Redis本身清理机制未及时清除spring:session:sessions:expires，可以通过Spring Session提供的定时任务兜底，保证spring:session:sessions:expires清除。</p><p>RedisSessionExpirationPolicy，session清理定时任务</p><p>public void cleanExpiredSessions() {\n &nbsp; &nbsp; &nbsp; &nbsp;long now = System.currentTimeMillis();\n &nbsp; &nbsp; &nbsp; &nbsp;long prevMin = roundDownMinute(now);\n &nbsp; &nbsp; &nbsp; &nbsp;......\n &nbsp; &nbsp; &nbsp; &nbsp;<i>//获取到spring:session:expirations键\n</i> &nbsp; &nbsp; &nbsp; &nbsp;String expirationKey = getExpirationKey(prevMin);\n &nbsp; &nbsp; &nbsp; &nbsp;<i>// 取出当前这一分钟应当过期的 session\n</i> &nbsp; &nbsp; &nbsp; &nbsp;Set&lt;Object&gt; sessionsToExpire = this.redis.boundSetOps(expirationKey).members();\n &nbsp; &nbsp; &nbsp; &nbsp;<i>// 注意：这里删除的是spring:session:expirations键，不是删除 session 本身！\n</i> &nbsp; &nbsp; &nbsp; &nbsp;this.redis.delete(expirationKey);\n &nbsp; &nbsp; &nbsp; &nbsp;for (Object session : sessionsToExpire) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;String sessionKey = getSessionKey((String) session);\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i>//遍历一下spring:session:sessions:expires键\n</i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;touch(sessionKey);\n &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp;}\n \n &nbsp; &nbsp;<i>/**\n &nbsp; &nbsp; * By trying to access the session we only trigger a deletion if it the TTL is\n &nbsp; &nbsp; * expired. This is done to handle\n &nbsp; &nbsp; * https://github.com/spring-projects/spring-session/issues/93\n &nbsp; &nbsp; *\n &nbsp; &nbsp; * @param key the key\n &nbsp; &nbsp; */</i>\n &nbsp; &nbsp;private void touch(String key) {\n &nbsp; &nbsp; &nbsp; &nbsp;<i>//并不是直接删除 key，而只是访问 key，通过惰性删除确保spring:session:sessions:expires键实时删除，\n</i> &nbsp; &nbsp; &nbsp; &nbsp;<i>// 同时也保证多线程并发续签的场景下，key移动到不同spring:session:expirations键里面时，\n</i> &nbsp; &nbsp; &nbsp; &nbsp;<i>//以spring:session:sessions:expires键实际ttl时间为准\n</i> &nbsp; &nbsp; &nbsp; &nbsp;this.redis.hasKey(key);\n &nbsp; &nbsp;}</p><h3>5、事件订阅</h3><p>默认至少订阅键空间通知gxE事件（<a href=\"https://link.zhihu.com/?target=http%3A//redisdoc.com/topic/notification.html%25EF%25BC%2589%25E3%2580%2582\">http://redisdoc.com/topic/notification.html）。</a></p><p>ConfigureNotifyKeyspaceEventsAction，开启键空间通知：</p><p>public void configure(RedisConnection connection) {\n &nbsp; &nbsp; &nbsp; String notifyOptions = getNotifyOptions(connection);\n &nbsp; &nbsp; &nbsp; String customizedNotifyOptions = notifyOptions;\n &nbsp; &nbsp; &nbsp; if (!customizedNotifyOptions.contains(\"E\")) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; customizedNotifyOptions += \"E\";\n &nbsp; &nbsp; &nbsp; }\n &nbsp; &nbsp; &nbsp; boolean A = customizedNotifyOptions.contains(\"A\");\n &nbsp; &nbsp; &nbsp; if (!(A || customizedNotifyOptions.contains(\"g\"))) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; customizedNotifyOptions += \"g\";\n &nbsp; &nbsp; &nbsp; }\n &nbsp; &nbsp; &nbsp; if (!(A || customizedNotifyOptions.contains(\"x\"))) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; customizedNotifyOptions += \"x\";\n &nbsp; &nbsp; &nbsp; }\n &nbsp; &nbsp; &nbsp; if (!notifyOptions.equals(customizedNotifyOptions)) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connection.setConfig(CONFIG_NOTIFY_KEYSPACE_EVENTS, customizedNotifyOptions);\n &nbsp; &nbsp; &nbsp; }\n &nbsp; }</p><p>RedisHttpSessionConfiguration，注册监听事件：</p><p>@Bean\n public RedisMessageListenerContainer redisMessageListenerContainer(\n &nbsp; &nbsp; &nbsp; &nbsp; RedisConnectionFactory connectionFactory,\n &nbsp; &nbsp; &nbsp; &nbsp; RedisOperationsSessionRepository messageListener) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ......\n &nbsp; &nbsp;&nbsp;<i>//psubscribe del和expired事件\n</i> &nbsp; &nbsp; container.addMessageListener(messageListener,\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Arrays.asList(new PatternTopic(\"__keyevent@*:del\"),\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new PatternTopic(\"__keyevent@*:expired\")));\n &nbsp; &nbsp;&nbsp;<i>//psubscribe created事件\n</i> &nbsp; &nbsp; container.addMessageListener(messageListener, Arrays.asList(new PatternTopic(\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; messageListener.getSessionCreatedChannelPrefix() + \"*\")));\n &nbsp; &nbsp; return container;\n }</p><p>RedisOperationsSessionRepository，事件处理：</p><p>public void onMessage(Message message, byte[] pattern) {\n &nbsp; &nbsp; &nbsp;......\n &nbsp; &nbsp; &nbsp;if (channel.startsWith(getSessionCreatedChannelPrefix())) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i>//处理spring:session created事件\n</i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;handleCreated(loaded, channel);\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return;\n &nbsp; &nbsp; &nbsp;}\n \n &nbsp; &nbsp; &nbsp;<i>//非spring:session:sessions:expires事件不做处理\n</i> &nbsp; &nbsp; &nbsp;String body = new String(messageBody);\n &nbsp; &nbsp; &nbsp;if (!body.startsWith(getExpiredKeyPrefix())) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return;\n &nbsp; &nbsp; &nbsp;}\n \n &nbsp; &nbsp; &nbsp;boolean isDeleted = channel.endsWith(\":del\");\n &nbsp; &nbsp; &nbsp;if (isDeleted || channel.endsWith(\":expired\")) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;......\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (isDeleted) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i>//处理spring:session:sessions:expires del事件\n</i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;handleDeleted(sessionId, session);\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i>//处理spring:session:sessions:expires expired事件\n</i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;handleExpired(sessionId, session);\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;......\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return;\n &nbsp; &nbsp; &nbsp;}\n &nbsp;}</p><p>事件订阅样例：</p><p>@Component\npublic class SessionExpiredListener implements ApplicationListener&lt;SessionExpiredEvent&gt; {\n &nbsp; &nbsp;@Override\n &nbsp; &nbsp;public void onApplicationEvent(SessionExpiredEvent event) {\n &nbsp; &nbsp; &nbsp; &nbsp;......\n &nbsp; &nbsp;}\n}</p><h3>6、总结</h3><p>Spring Session给我们提供了很好的分布式环境下资源共享问题解决思路，其基于Servlet 规范实现，业务使用时只需要简单配置就可以实现session共享，做到与业务低耦合，这都是以后我们项目开发中可以借签的设计理念。</p>',18,0,0,0,NULL),(21,27,'<p>关于synchronized的底层实现，网上有很多文章了。但是很多文章要么作者根本没看代码，仅仅是根据网上其他文章总结、照搬而成，难免有些错误；要么很多点都是一笔带过，对于为什么这样实现没有一个说法，让像我这样的读者意犹未尽。</p><p>本系列文章将对HotSpot的synchronized锁实现进行全面分析，内容包括偏向锁、轻量级锁、重量级锁的加锁、解锁、锁升级流程的原理及源码分析，希望给在研究synchronized路上的同学一些帮助。</p><p>大概花费了两周的实现看代码（花费了这么久时间有些忏愧，主要是对C++、JVM底层机制、JVM调试以及汇编代码不太熟），将synchronized涉及到的代码基本都看了一遍，其中还包括在JVM中添加日志验证自己的猜想，总的来说目前对synchronized这块有了一个比较全面清晰的认识，但水平有限，有些细节难免有些疏漏，还望请大家指正。</p><p>本篇文章将对synchronized机制做个大致的介绍，包括用以承载锁状态的对象头、锁的几种形式、各种形式锁的加锁和解锁流程、什么时候会发生锁升级。<strong>需要注意的是本文旨在介绍背景和概念，在讲述一些流程的时候，只提到了主要case，对于实现细节、运行时的不同分支都在后面的文章中详细分析</strong>。</p><p>本人看的JVM版本是jdk8u，具体版本号以及代码可以在<a href=\"https://link.zhihu.com/?target=http%3A//hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683\">这里</a>看到。</p><h2>synchronized简介</h2><p>Java中提供了两种实现同步的基础语义：synchronized方法和synchronized块， 我们来看个demo：</p><p>public class SyncTest {\n &nbsp; &nbsp;public void syncBlock(){\n &nbsp; &nbsp; &nbsp; &nbsp;synchronized (this){\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"hello block\");\n &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp;}\n &nbsp; &nbsp;public synchronized void syncMethod(){\n &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"hello method\");\n &nbsp; &nbsp;}\n}</p><p>当SyncTest.java被编译成class文件的时候，synchronized关键字和synchronized方法的字节码略有不同，我们可以用javap -v 命令查看class文件对应的JVM字节码信息，部分信息如下：</p><p>{\n &nbsp;public void syncBlock();\n &nbsp; &nbsp;descriptor: ()V\n &nbsp; &nbsp;flags: ACC_PUBLIC\n &nbsp; &nbsp;Code:\n &nbsp; &nbsp; &nbsp;stack=2, locals=3, args_size=1\n &nbsp; &nbsp; &nbsp; &nbsp; 0: aload_0\n &nbsp; &nbsp; &nbsp; &nbsp; 1: dup\n &nbsp; &nbsp; &nbsp; &nbsp; 2: astore_1\n &nbsp; &nbsp; &nbsp; &nbsp; 3: monitorenter				 	 &nbsp;// monitorenter指令进入同步块\n &nbsp; &nbsp; &nbsp; &nbsp; 4: getstatic &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;\n &nbsp; &nbsp; &nbsp; &nbsp; 7: ldc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// String hello block\n &nbsp; &nbsp; &nbsp; &nbsp; 9: invokevirtual #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V\n &nbsp; &nbsp; &nbsp; &nbsp;12: aload_1\n &nbsp; &nbsp; &nbsp; &nbsp;13: monitorexit						 &nbsp;// monitorexit指令退出同步块\n &nbsp; &nbsp; &nbsp; &nbsp;14: goto &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22\n &nbsp; &nbsp; &nbsp; &nbsp;17: astore_2\n &nbsp; &nbsp; &nbsp; &nbsp;18: aload_1\n &nbsp; &nbsp; &nbsp; &nbsp;19: monitorexit						 &nbsp;// monitorexit指令退出同步块\n &nbsp; &nbsp; &nbsp; &nbsp;20: aload_2\n &nbsp; &nbsp; &nbsp; &nbsp;21: athrow\n &nbsp; &nbsp; &nbsp; &nbsp;22: return\n &nbsp; &nbsp; &nbsp;Exception table:\n &nbsp; &nbsp; &nbsp; &nbsp; from &nbsp; &nbsp;to &nbsp;target type\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp;14 &nbsp; &nbsp;17 &nbsp; any\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;17 &nbsp; &nbsp;20 &nbsp; &nbsp;17 &nbsp; any\n \n\n &nbsp;public synchronized void syncMethod();\n &nbsp; &nbsp;descriptor: ()V\n &nbsp; &nbsp;flags: ACC_PUBLIC, ACC_SYNCHRONIZED &nbsp; &nbsp; &nbsp;//添加了ACC_SYNCHRONIZED标记\n &nbsp; &nbsp;Code:\n &nbsp; &nbsp; &nbsp;stack=2, locals=1, args_size=1\n &nbsp; &nbsp; &nbsp; &nbsp; 0: getstatic &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;\n &nbsp; &nbsp; &nbsp; &nbsp; 3: ldc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// String hello method\n &nbsp; &nbsp; &nbsp; &nbsp; 5: invokevirtual #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V\n &nbsp; &nbsp; &nbsp; &nbsp; 8: return\n \n}</p><p>从上面的中文注释处可以看到，对于synchronized关键字而言，javac在编译时，会生成对应的monitorenter和monitorexit指令分别对应synchronized同步块的进入和退出，有两个monitorexit指令的原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用monitorexit命令释放锁。而对于synchronized方法而言，javac为其生成了一个ACC_SYNCHRONIZED关键字，在JVM进行方法调用时，发现调用的方法被ACC_SYNCHRONIZED修饰，则会先尝试获得锁。</p><p>在JVM底层，对于这两种synchronized语义的实现大致相同，在后文中会选择一种进行详细分析。</p><p>因为本文旨在分析synchronized的实现原理，因此对于其使用的一些问题就不赘述了，不了解的朋友可以看看<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/luoweifu/article/details/46613015\">这篇文章</a>。</p><h2>锁的几种形式</h2><p>传统的锁（也就是下文要说的重量级锁）依赖于系统的同步函数，在linux上使用mutex互斥锁，最底层实现依赖于futex，关于futex可以看我之前的<a href=\"https://link.zhihu.com/?target=https%3A//github.com/farmerjohngit/myblog/issues/8\">文章</a>，这些同步函数都涉及到用户态和内核态的切换、进程的上下文切换，成本较高。对于加了synchronized关键字但<strong>运行时并没有多线程竞争，或两个线程接近于交替执行的情况</strong>，使用传统锁机制无疑效率是会比较低的。</p><p>在JDK 1.6之前,synchronized只有传统的锁机制，因此给开发者留下了synchronized关键字相比于其他同步机制性能不好的印象。</p><p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p><p>在看这几种锁机制的实现前，我们先来了解下对象头，它是实现多种锁机制的基础。</p><h3>对象头</h3><p>因为在Java中任意对象都可以用作锁，因此必定要有一个映射关系，存储该对象以及其对应的锁信息（比如当前哪个线程持有锁，哪些线程在等待）。一种很直观的方法是，用一个全局map，来存储这个映射关系，但这样会有一些问题：需要对map做线程安全保障，不同的synchronized之间会相互影响，性能差；另外当同步对象较多时，该map可能会占用比较多的内存。</p><p>所以最好的办法是将这个映射关系存储在对象头中，因为对象头本身也有一些hashcode、GC相关的数据，所以如果能将锁信息与这些信息<strong>共存</strong>在对象头中就好了。</p><p>在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。另外对于数组而言还会有一份记录数组长度的数据。</p><p>类型指针是指向该对象所属类对象的指针，mark word用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上mark word长度为32bit，64位系统上长度为64bit。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下：</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic4.zhimg.com/80/v2-36ba2888b057e37277c0c69678b0a57b_hd.jpg\"></figure><p><br>&nbsp;</p><p>可以看到锁信息也是存在于对象的mark word中的。当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p><h3>重量级锁</h3><p>重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。</p><p>重量级锁的状态下，对象的mark word为指向一个堆中monitor对象的指针。</p><p>一个monitor对象包括这么几个关键字段：cxq（下图中的ContentionList），EntryList ，WaitSet，owner。</p><p>其中cxq ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic3.zhimg.com/80/v2-4ff4a20f2cbfc45df9b77bfa98befab2_hd.jpg\"></figure><p><br>&nbsp;</p><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p><p>如果一个线程在同步块中调用了Object#wait方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p><p>以上只是对重量级锁流程的一个简述，其中涉及到的很多细节，比如ObjectMonitor对象从哪来？释放锁时是将cxq中的元素移动到EntryList的尾部还是头部？notfiy时，是将ObjectWaiter移动到EntryList的尾部还是头部？</p><p>关于具体的细节，会在重量级锁的文章中分析。</p><h3>轻量级锁</h3><p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p><p>线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个Lock Record，其包括一个用于存储对象头中的 mark word（官方称之为Displaced Mark Word）以及一个指向对象的指针。下图右边的部分就是一个Lock Record。</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-af989e3ffb805bf37dd25ab40e78e858_hd.jpg\"></figure><p><br>&nbsp;</p><h3>加锁过程</h3><p>1.在线程栈中创建一个Lock Record，将其obj（即上图的Object reference）字段指向锁对象。</p><p>2.直接通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入到步骤3。</p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。然后结束。</p><p>4.走到这一步说明发生了竞争，需要膨胀为重量级锁。</p><h3>解锁过程</h3><p>1.遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p><p>2.如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p><p>3.如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为Displaced Mark Word。如果成功，则continue，否则膨胀为重量级锁。</p><h3>偏向锁</h3><p>Java是支持多线程的语言，因此在很多二方包、基础库中为了保证代码在多线程的情况下也能正常运行，也就是我们常说的线程安全，都会加入如synchronized这样的同步语义。但是在应用在实际运行时，很可能只有一个线程会调用相关同步方法。比如下面这个demo：</p><p>import java.util.ArrayList;\nimport java.util.List;\n\npublic class SyncDemo1 {\n\n &nbsp; &nbsp;public static void main(String[] args) {\n &nbsp; &nbsp; &nbsp; &nbsp;SyncDemo1 syncDemo1 = new SyncDemo1();\n &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; 100; i++) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;syncDemo1.addString(\"test:\" + i);\n &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp;}\n\n &nbsp; &nbsp;private List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n &nbsp; &nbsp;public synchronized void addString(String s) {\n &nbsp; &nbsp; &nbsp; &nbsp;list.add(s);\n &nbsp; &nbsp;}\n\n}</p><p>在这个demo中为了保证对list操纵时线程安全，对addString方法加了synchronized的修饰，但实际使用时却只有一个线程调用到该方法，对于轻量级锁而言，每次调用addString时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作（这里的’一个‘、’多个‘数量词只是针对该demo，并不适用于所有场景）。</p><p>在JDK1.6中为了<strong>提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能</strong>，引入了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的CAS命令。我们来看看偏向锁是如何做的。</p><h3>对象创建</h3><p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（什么时候会关闭一个class的偏向模式下文会说，默认所有class的偏向模式都是是开启的），那新创建对象的mark word将是可偏向状态，此时mark word中的thread id（参见上文偏向状态下的mark word格式）为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</p><h3>加锁过程</h3><p>case 1：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将mark word中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。</p><p>case 2：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。</p><p>case 3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到<strong>撤销偏向锁</strong>的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的mark word改为无锁状态（unlocked），之后再升级为轻量级锁。</p><p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p><h3>解锁过程</h3><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的lock record来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条lock record的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中<strong>并不会修改对象头中的thread id。</strong></p><p>下图展示了锁状态的转换流程：</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic4.zhimg.com/80/v2-f93353a5dd7cf0f9446af473f9eac947_hd.jpg\"></figure><p><br>&nbsp;</p><p>另外，偏向锁默认不是立即就启动的，在程序启动后，通常有几秒的延迟，可以通过命令 -XX:BiasedLockingStartupDelay=0来关闭延迟。</p><h3>批量重偏向与撤销</h3><p>从上文偏向锁的加锁解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。safe point这个词我们在GC中经常会提到，其代表了一个状态，在该状态下所有线程都是暂停的（大概这么个意思），详细可以看这篇<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/ITer_ZC/article/details/41892567\">文章</a>。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p><p>存在如下两种情况：（见官方<a href=\"https://link.zhihu.com/?target=https%3A//www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf\">论文</a>第4小节）:</p><p>1.一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</p><p>2.存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</p><p>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</p><p>其做法是：以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时，class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。</p><p>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>',18,0,0,0,NULL),(22,28,'<h2><strong>面向对象的三个特征</strong></h2><p>封装，继承，多态，这个应该是人人皆知，有时候也会加上抽象。</p><h2><strong>多态的好处</strong></h2><p>允许不同类对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用)。主要有以下优点：</p><ol><li>可替换性：多态对已存在代码具有可替换性</li><li>可扩充性：增加新的子类不影响已经存在的类结构</li><li>接口性：多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的。</li><li>灵活性</li><li>简化性</li></ol><h2><strong>代码中如何实现多态</strong></h2><p>实现多态主要有以下三种方式：<br>1. 接口实现&nbsp;<br>2. 继承父类重写方法&nbsp;<br>3. 同一类中进行方法重载</p><h2><strong>虚拟机是如何实现多态的</strong></h2><p>动态绑定技术(dynamic binding)，执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法。</p><h2><strong>接口的意义</strong></h2><p>接口的意义用三个词就可以概括：规范，扩展，回调。</p><h2><strong>抽象类的意义</strong></h2><p>抽象类的意义可以用三句话来概括：</p><ol><li>为其他子类提供一个公共的类型</li><li>封装子类中重复定义的内容</li><li>定义抽象方法,子类虽然有不同的实现，但是定义时一致的</li></ol><h2><strong>接口和抽象类的区别</strong></h2><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-aab16b57477de5992c0bda069d0d972c_hd.jpg\"></figure><p><strong>父类的静态方法能否被子类重写</strong></p><p>不能。重写只适用于实例方法,不能用于静态方法，而子类当中含有和父类相同签名的静态方法，我们一般称之为隐藏。</p><h2><strong>什么是不可变对象</strong></h2><p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。</p><h2><strong>静态变量和实例变量的区别?</strong></h2><p>静态变量存储在方法区，属于类所有。实例变量存储在堆当中，其引用存在当前线程栈。</p><h2><strong>能否创建一个包含可变对象的不可变对象?</strong></h2><p>当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。</p><h2><strong>java 创建对象的几种方式</strong></h2><ol><li>采用new</li><li>通过反射</li><li>采用clone</li><li>通过序列化机制</li></ol><p>前2者都需要显式地调用构造方法。造成耦合性最高的恰好是第一种，因此你发现无论什么框架，只要涉及到解耦必先减少new的使用。</p><h2><strong>switch中能否使用string做参数</strong></h2><p>在idk 1.7之前，switch只能支持byte, short, char, int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String。</p><h2><strong>switch能否作用在byte, long上?</strong></h2><p>可以用在byte上，但是不能用在long上。</p><h2><strong>String s1=”ab”, String s2=”a”+”b”, String s3=”a”, String s4=”b”, s5=s3+s4请问s5==s2返回什么？</strong></h2><p>返回false。在编译过程中，编译器会将s2直接优化为”ab”，会将其放置在常量池当中，s5则是被创建在堆区，相当于s5=new String(“ab”);</p><h2><strong>你对String对象的intern()熟悉么?</strong></h2><p>intern()方法会首先从常量池中查找是否存在该常量值，如果常量池中不存在则现在常量池中创建，如果已经存在则直接返回。<br>比如&nbsp;<br>String s1=”aa”;&nbsp;<br>String s2=s1.intern();&nbsp;<br>System.out.print(s1==s2);//返回true</p><h2><strong>Object中有哪些公共方法?</strong></h2><ol><li>equals()</li><li>clone()</li><li>getClass()</li><li>notify(),notifyAll(),wait()</li><li>toString<br>&nbsp;</li></ol><h2><strong>java当中的四种引用</strong></h2><p>强引用，软引用，弱引用，虚引用。不同的引用类型主要体现在GC上:</p><ol><li>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</li><li>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li><li>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。</li><li>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li></ol><h2><strong>WeakReference与SoftReference的区别?</strong></h2><p>这点在四种引用类型中已经做了解释,这里简单说明一下即可:&nbsp;<br>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</p><h2><strong>为什么要有不同的引用类型</strong></h2><p>不像C语言，我们可以控制内存的申请和释放，在Java中有时候我们需要适当的控制对象被回收的时机，因此就诞生了不同的引用类型，可以说不同的引用类型实则是对GC回收时机不可控的妥协。有以下几个使用场景可以充分的说明：</p><ol><li>利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.</li><li>通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次GC影响性能。此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。</li></ol><h2><strong>java中==和eqauls()的区别,equals()和`hashcode的区别</strong></h2><p>==是运算符，用于比较两个变量是否相等，而equals是Object类的方法，用于比较两个对象是否相等。默认Object类的equals方法是比较两个对象的地址，此时和==的结果一样。换句话说：基本类型比较用==，比较的是他们的值。默认下，对象用==比较时，比较的是内存地址，如果需要比较对象内容，需要重写equal方法。</p><h2><strong>equals()和hashcode()的联系</strong></h2><p>hashCode()是Object类的一个方法，返回一个哈希值。如果两个对象根据equal()方法比较相等，那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值。<br>如果两个对象根据eqaul()方法比较不相等，那么产生的哈希值不一定相等(碰撞的情况下还是会相等的。)</p><h2><strong>a.hashCode()有什么用?与a.equals(b)有什么关系</strong></h2><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。</p><p>将对象放入到集合中时，首先判断要放入对象的hashcode是否已经在集合中存在，不存在则直接放入集合。如果hashcode相等，然后通过equal()方法判断要放入对象与集合中的任意对象是否相等：如果equal()判断不相等，直接将该元素放入集合中，否则不放入。</p><h2><strong>有没有可能两个不相等的对象有相同的hashcode</strong></h2><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。如果两个对象相等，必须有相同的hashcode 值，反之不成立。</p><h2><strong>可以在hashcode中使用随机数字吗?</strong></h2><p>不行，因为同一对象的 hashcode 值必须是相同的</p><h2><strong>a==b与a.equals(b)有什么区别</strong></h2><p>如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p><h2><strong>3*0.1==0.3返回值是什么</strong></h2><p>false，因为有些浮点数不能完全精确的表示出来。</p><h2><strong>a=a+b与a+=b有什么区别吗?</strong></h2><p>+=操作符会进行隐式自动类型转换，此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，而a=a+b则不会自动进行类型转换。如：<br>byte a = 127;&nbsp;<br>byte b = 127;&nbsp;<br>b = a + b; // error : cannot convert from int to byte&nbsp;<br>b += a; // ok&nbsp;<br>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）</p><h2><strong>short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？</strong></h2><p>有错误，short类型在进行运算时会自动提升为int类型，也就是说s1+1的运算结果是int类型。</p><h2>short s1= 1; s1 += 1; 该段代码是否有错，有的话怎么改？</h2><p>+=操作符会自动对右边的表达式结果强转匹配左边的数据类型，所以没错。</p><h2><strong>&amp; 和 &amp;&amp;的区别</strong></h2><p>首先记住&amp;是位操作，而&amp;&amp;是逻辑运算符。另外需要记住逻辑运算符具有短路特性，而&amp;不具备短路特性。</p><figure class=\"image\"><img src=\"https://pic2.zhimg.com/80/v2-668594d57aaa216b0e36b606fd3a5129_hd.jpg\"></figure><p>以上代码将会抛出空指针异常。</p><h2><strong>一个java文件内部可以有类？(非内部类)</strong></h2><p>只能有一个public公共类，但是可以有多个default修饰的类。</p><h2><strong>如何正确的退出多层嵌套循环？</strong></h2><ol><li>使用标号和break;</li><li>通过在外层循环中添加标识符<br>&nbsp;</li></ol><h2><strong>内部类的作用</strong></h2><p>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立.在单个外围类当中，可以让多个内部类以不同的方式实现同一接口，或者继承同一个类.创建内部类对象的时刻不依赖于外部类对象的创建。内部类并没有令人疑惑的”is-a”管系，它就像是一个独立的实体。</p><p>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p><h2><strong>final, finalize和finally的不同之处</strong></h2><p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p><h2><strong>clone()是哪个类的方法?</strong></h2><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p><h2><strong>深拷贝和浅拷贝的区别是什么?</strong></h2><p>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p><p>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</p><h2><strong>static都有哪些用法?</strong></h2><p>几乎所有的人都知道static关键字这两个基本的用法：静态变量和静态方法。也就是被static所修饰的变量/方法都属于类的静态资源，类实例所共享。</p><p>除了静态变量和静态方法之外，static也用于静态块，多用于初始化操作：</p><figure class=\"image\"><img src=\"https://pic2.zhimg.com/80/v2-6ebc6302307f1dc74b99dcee2b66031d_hd.jpg\"></figure><p><br>&nbsp;</p><p>此外static也多用于修饰内部类，此时称之为静态内部类。</p><p>最后一种用法就是静态导包，即import static.import static是在JDK 1.5之后引入的新特性，可以用来指定导入某个类中的静态资源，并且不需要使用类名。资源名，可以直接使用资源名，比如：</p><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-dc241d6e66dd5967a7edca7d2c064f00_hd.jpg\"></figure><p><strong>final有哪些用法</strong></p><p>final也是很多面试喜欢问的地方，能回答下以下三点就不错了：<br>1.被final修饰的类不可以被继承&nbsp;<br>2.被final修饰的方法不可以被重写&nbsp;<br>3.被final修饰的变量不可以被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变。<br>4.被final修饰的方法，JVM会尝试将其内联，以提高运行效率&nbsp;<br>5.被final修饰的常量，在编译阶段会存入常量池中。</p><p>回答出编译器对final域要遵守的两个重排序规则更好：<br>1.在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序。<br>2.初次读一个包含final域的对象的引用，与随后初次读这个final域,这两个操作之间不能重排序。</p><h2><strong>数据类型相关</strong></h2><h2><strong>java中int char,long各占多少字节?</strong></h2><figure class=\"image\"><img src=\"https://pic3.zhimg.com/80/v2-1fc401d2796184709539f43d40351012_hd.jpg\"></figure><p><br><strong>64位的JVM当中,int的长度是多少?</strong></p><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p><h2><strong>int和Integer的区别</strong></h2><p>Integer是int的包装类型，在拆箱和装箱中，二者自动转换。int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象。</p><h2><strong>int 和Integer谁占用的内存更多?</strong></h2><p>Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p><h2><strong>String, StringBuffer和StringBuilder区别</strong></h2><p>String是字符串常量，final修饰：StringBuffer字符串变量(线程安全)；<br>StringBuilder 字符串变量(线程不安全)。</p><h2><strong>String和StringBuffer</strong></h2><p>String和StringBuffer主要区别是性能：String是不可变对象，每次对String类型进行操作都等同于产生了一个新的String对象，然后指向新的String对象。所以尽量不在对String进行大量的拼接操作，否则会产生很多临时对象，导致GC开始工作，影响系统性能。</p><p>StringBuffer是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用StringBuffer。</p><p>但是需要注意现在JVM会对String拼接做一定的优化：<br>String s=“This is only ”+”simple”+”test”会被虚拟机直接优化成String s=“This is only simple test”，此时就不存在拼接过程。</p><h2><strong>StringBuffer和StringBuilder</strong></h2><p>StringBuffer是线程安全的可变字符串，其内部实现是可变数组。StringBuilder是jdk 1.5新增的，其功能和StringBuffer类似，但是非线程安全。因此，在没有多线程问题的前提下，使用StringBuilder会取得更好的性能。</p><h2><strong>什么是编译器常量？使用它有什么风险？</strong></h2><p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p><h2><strong>java当中使用什么类型表示价格比较好?</strong></h2><p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p><h2><strong>如何将byte转为String</strong></h2><p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p><h2><strong>可以将int强转为byte类型么?会产生什么问题?</strong></h2><p>我们可以做强制转换，但是Java中int是32位的而byte是8 位的，所以,如果强制转化int类型的高24位将会被丢弃，byte 类型的范围是从-128到128</p><h2><strong>关于垃圾回收</strong></h2><h2><strong>你知道哪些垃圾回收算法?</strong></h2><p>垃圾回收从理论上非常容易理解,具体的方法有以下几种:&nbsp;<br>1. 标记-清除&nbsp;<br>2. 标记-复制&nbsp;<br>3. 标记-整理&nbsp;<br>4. 分代回收</p><h2><strong>如何判断一个对象是否应该被回收</strong></h2><p>这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析。由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法。</p><h2><strong>简单的解释一下垃圾回收</strong></h2><p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。</p><h2><strong>调用System.gc()会发生什么?</strong></h2><p>通知GC开始工作，但是GC真正开始的时间不确定。</p><h2><strong>进程,线程相关</strong></h2><h2><strong>说说进程，线程，协程之间的区别</strong></h2><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p><h2><strong>你了解守护线程吗？它和非守护线程有什么区别</strong></h2><p>程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程。守护线程最典型的例子就是GC线程。</p><h2><strong>什么是多线程上下文切换</strong></h2><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><h2><strong>创建两种线程的方式?他们有什么区别?</strong></h2><p>通过实现java.lang.Runnable或者通过扩展java.lang.Thread类。相比扩展Thread，实现Runnable接口可能更优.原因有二：</p><ol><li>Java不支持多继承。因此扩展Thread类就代表这个子类不能扩展其他类。而实现Runnable接口的类还可能扩展另一个类。</li><li>类可能只要求可执行即可，因此继承整个Thread类的开销过大。</li></ol><h2><strong>Thread类中的start()和run()方法有什么区别?</strong></h2><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p><h2><strong>怎么检测一个线程是否持有对象监视器</strong></h2><p>Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p><h2><strong>Runnable和Callable的区别</strong></h2><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。&nbsp;<br>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务。</p><h2><strong>什么导致线程阻塞</strong></h2><p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-364d796e15e35faa67943e25d354d79c_hd.jpg\"></figure><p><br><strong>wait(),notify()和suspend(),resume()之间的区别</strong></p><p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。</p><p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p><p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p><p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p><p>关于 wait() 和 notify() 方法最后再说明两点：&nbsp;<br>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p><p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p><p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p><p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p><h2><strong>产生死锁的条件</strong></h2><p>1.互斥条件：一个资源每次只能被一个进程使用。&nbsp;<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。&nbsp;<br>3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。&nbsp;<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><h2><strong>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</strong></h2><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><h2><strong>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</strong></h2><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p><h2><strong>wait()与sleep()的区别</strong></h2><p>关于这两者已经在上面进行详细的说明,这里就做个概括好了:</p><ul><li>sleep()来自Thread类，和wait()来自Object类。调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li><li>sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU</li><li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用<br><br>&nbsp;</li></ul><h2><strong>为什么wait, nofity和nofityAll这些方法不放在Thread类当中</strong></h2><p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h2><strong>怎么唤醒一个阻塞的线程</strong></h2><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><h2><strong>什么是多线程的上下文切换</strong></h2><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><h2><strong>synchronized和ReentrantLock的区别</strong></h2><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：&nbsp;<br>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁&nbsp;<br>（2）ReentrantLock可以获取各种锁的信息&nbsp;<br>（3）ReentrantLock可以灵活地实现多路通知&nbsp;<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p><h2><strong>FutureTask是什么</strong></h2><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><h2><strong>一个线程如果出现了运行时异常怎么办?</strong></h2><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。</p><h2><strong>Java当中有哪几种锁</strong></h2><ol><li>自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定。</li><li>偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。</li><li>轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</li></ol><h2><strong>如何在两个线程间共享数据</strong></h2><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。</p><h2><strong>如何正确的使用wait()？使用if还是while？</strong></h2><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p><figure class=\"image\"><img src=\"https://pic2.zhimg.com/80/v2-512d2bf64f6c420e6d57fdd50f2c6de1_hd.jpg\"></figure><h2><strong>什么是线程局部变量ThreadLocal</strong></h2><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><h2><strong>ThreadLoal的作用是什么?</strong></h2><p>简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p><h2><strong>生产者消费者模型的作用是什么?</strong></h2><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用。<br>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。</p><h2><strong>写一个生产者-消费者队列</strong></h2><p>可以通过阻塞队列实现，也可以通过wait-notify来实现。</p><h2><strong>使用阻塞队列来实现</strong></h2><blockquote><p><i>//消费者</i><br>public class Producer implements Runnable{<br>private final BlockingQueue&lt;Integer&gt; queue;<br>public Producer(BlockingQueue q){<br>this.queue=q;<br>}<br>@Override<br>public void run() {<br>try {<br>while (true){<br>Thread.sleep(1000);<i>//模拟耗时</i><br>queue.put(produce());<br>}<br>}catch (InterruptedException e){<br>}<br>}<br>private int produce() {<br>int n=new Random().nextInt(10000);<br>System.out.println(\"Thread:\" + Thread.currentThread().getId() + \" produce:\" + n);<br>return n;<br>}<br>}<br><i>//消费者</i><br>public class Consumer implements Runnable {<br>private final BlockingQueue&lt;Integer&gt; queue;<br>public Consumer(BlockingQueue q){<br>this.queue=q;<br>}<br>@Override<br>public void run() {<br>while (true){<br>try {<br>Thread.sleep(2000);<i>//模拟耗时</i><br>consume(queue.take());<br>}catch (InterruptedException e){<br>}<br>}<br>}<br>private void consume(Integer n) {<br>System.out.println(\"Thread:\" + Thread.currentThread().getId() + \" consume:\" + n);<br>}<br>}<br><i>//测试</i><br>public class Main {<br>public static void main(String[] args) {<br>BlockingQueue&lt;Integer&gt; queue=new ArrayBlockingQueue&lt;Integer&gt;(100);<br>Producer p=new Producer(queue);<br>Consumer c1=new Consumer(queue);<br>Consumer c2=new Consumer(queue);<br>new Thread(p).start();<br>new Thread(c1).start();<br>new Thread(c2).start();<br>}<br>}</p></blockquote><h2><strong>使用wait-notify来实现</strong></h2><p>该种方式应该最经典，这里就不做说明了。</p><h2><strong>如果你提交任务时，线程池队列已满，这时会发生什么</strong></h2><p>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p><h2><strong>为什么要使用线程池</strong></h2><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><h2><strong>java中用到的线程调度算法是什么</strong></h2><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><h2><strong>Thread.sleep(0)的作用是什么</strong></h2><p>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><h2><strong>什么是CAS</strong></h2><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><h2><strong>什么是乐观锁和悲观锁</strong></h2><p>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h2><strong>ConcurrentHashMap的并发度是什么?</strong></h2><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><h2><strong>ConcurrentHashMap的工作原理</strong></h2><p>ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的。</p><h2><strong>jdk 1.6:</strong></h2><p>ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。&nbsp;<br>具体实现:ConcurrentHashMap内部有一个Segment.</p><h2><strong>jdk 1.8</strong></h2><p>在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p><h2><strong>CyclicBarrier和CountDownLatch区别</strong></h2><p>这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><ul><li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行。</li><li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li><li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。</li></ul><h2><strong>java中的++操作符线程安全么?</strong></h2><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p><h2><strong>你有哪些多线程开发良好的实践?</strong></h2><ol><li>给线程命名</li><li>最小化同步范围</li><li>优先使用volatile</li><li>尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore</li><li>优先使用并发容器而非同步容器.</li><li>考虑使用线程池</li></ol><h2><strong>关于volatile关键字</strong></h2><h2><strong>可以创建Volatile数组吗?</strong></h2><p>Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了。</p><h2><strong>volatile能使得一个非原子操作变成原子操作吗?</strong></h2><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p><p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p><h2><strong>volatile类型变量提供什么保证?</strong></h2><p>volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的。</p><h2><strong>关于集合</strong></h2><h2><strong>Java中的集合及其继承关系</strong></h2><p>关于集合的体系是每个人都应该烂熟于心的,尤其是对我们经常使用的List,Map的原理更该如此.这里我们看这张图即可:</p><h2><strong>poll()方法和remove()方法区别？</strong></h2><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p><h2><strong>LinkedHashMap和PriorityQueue的区别</strong></h2><p>PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p><h2><strong>WeakHashMap与HashMap的区别是什么?</strong></h2><p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p><h2><strong>ArrayList和LinkedList的区别?</strong></h2><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p><h2><strong>ArrayList和Array有什么区别?</strong></h2><ol><li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li><li>Array是指定大小的，而ArrayList大小是固定的</li></ol><h2><strong>ArrayList和HashMap默认大小?</strong></h2><p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段。</p><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-9ce5e8e673de266459e3dae5ab503db0_hd.png\"></figure><h2><strong>Comparator和Comparable的区别?</strong></h2><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p><h2><strong>如何实现集合排序?</strong></h2><p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p><h2><strong>如何打印数组内容</strong></h2><p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p><h2><strong>LinkedList的是单向链表还是双向?</strong></h2><p>双向循环列表，具体实现自行查阅源码。</p><h2><strong>TreeMap是实现原理</strong></h2><p>采用红黑树实现，具体实现自行查阅源码。</p><h2><strong>遍历ArrayList时如何正确移除一个元素</strong></h2><p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p><h2><strong>什么是ArrayMap?它和HashMap有什么区别?</strong></h2><p>ArrayMap是Android SDK中提供的，非Android开发者可以略过。<br>ArrayMap是用两个数组来模拟map，更少的内存占用空间,更高的效率。</p><h2><strong>HashMap的实现原理</strong></h2><p>1. HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&nbsp;<br>2. HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上.</p><p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p><h2><strong>你了解Fail-Fast机制吗？</strong></h2><p>Fail-Fast即我们常说的快速失败，</p><h2><strong>Fail-fast和Fail-safe有什么区别</strong></h2><p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-&gt;fast的，而java.util.concurrent中的集合类都为fail-safe的。当检测到正在遍历的集合的结构被改变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p><h2><strong>关于日期</strong></h2><h2><strong>SimpleDateFormat是线程安全的吗?</strong></h2><p>非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p><h2><strong>如何格式化日期?</strong></h2><p>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p><h2><strong>关于异常</strong></h2><h2><strong>简单描述java异常体系</strong></h2><p>相比没有人不了解异常体系,关于异常体系的更多信息可以见</p><h2><strong>什么是异常链</strong></h2><p>详情直接参见上面的白话异常机制，不做解释了。</p><h2><strong>throw和throws的区别</strong></h2><p>throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″),&nbsp;<br>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p><h2><strong>关于序列化</strong></h2><h2><strong>Java 中，Serializable 与 Externalizable 的区别</strong></h2><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p><h2><strong>关于JVM</strong></h2><h2><strong>JVM特性</strong></h2><p>平台无关性.&nbsp;<br>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p><h2><strong>简单解释一下类加载器</strong></h2><p>有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,</p><h2><strong>简述堆和栈的区别</strong></h2><p>VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p><h2><strong>简述JVM内存分配</strong></h2><ol><li>基本数据类型比变量和对象的引用都是在栈分配的。</li><li>堆内存用来存放由new创建的对象和数组。</li><li>类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中。</li><li>实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。</li><li>局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。</li></ol><h2><strong>其他</strong></h2><h2><strong>java当中采用的是大端还是小端?</strong></h2><h2><strong>XML解析的几种方式和特点</strong></h2><p>DOM, SAX, PULL三种解析方式：</p><ul><li>DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机</li><li>SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</li><li>PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。</li></ul><h2><strong>JDK 1.7特性</strong></h2><p>然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。</p><h2><strong>JDK 1.8特性</strong></h2><p>java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：&nbsp;<br>Lambda 表达式，允许像对象一样传递匿名函数&nbsp;<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码&nbsp;<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用&nbsp;<br>扩展方法，现在，接口中可以有静态、默认方法。&nbsp;<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。</p><h2><strong>Maven和ANT有什么区别?</strong></h2><p>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件。</p><h2><strong>JDBC最佳实践</strong></h2><ul><li>优先使用批量操作来插入和更新数据</li><li>使用PreparedStatement来避免SQL漏洞</li><li>使用数据连接池</li><li>通过列名来获取结果集</li></ul><h2><strong>IO操作最佳实践</strong></h2><ul><li>使用有缓冲的IO类,不要单独读取字节或字符</li><li>使用NIO和NIO 2或者AIO,而非BIO</li><li>在finally中关闭流</li><li>使用内存映射文件获取更快的IO</li></ul>',18,0,0,0,NULL),(23,24,'<h2>Redis 概述</h2><p>在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p><h2>NoSQL 技术</h2><p>为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种<strong>基于内存的数据库</strong>，并且提供一定的持久化功能。</p><p><strong>Redis</strong>和<strong>MongoDB</strong>是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以<strong>支持每秒十几万此的读/写操作</strong>，其性能远超数据库，并且还<strong>支持集群、分布式、主从同步等</strong>配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还<strong>支持一定的事务能力</strong>，这保证了高并发的场景下数据的安全和一致性。</p><h2>Redis 在 Java Web 中的应用</h2><p>Redis 在 Java Web 主要有两个应用场景：</p><ul><li>存储 <strong>缓存</strong> 用的数据；</li><li>需要高速读/写的场合<strong>使用它快速读/写</strong>；</li></ul><h2>缓存</h2><p>在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会<strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p><p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端<strong>直接去读取内存中的数据</strong>，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们<strong>只是使用 Redis 存储一些常用和主要的数据</strong>，比如用户登录的信息等。</p><p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p><ul><li>**业务数据常用吗？命中率如何？**如果命中率很低，就没有必要写入缓存；</li><li>**该业务数据是读操作多，还是写操作多？**如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li><li>**业务数据大小如何？**如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</li></ul><p>在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！使用 Redis 作为缓存的读取逻辑如下图所示：</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-59e6bc0e759f911af90ef2ce04580fc8_hd.jpg\"></figure><p><br>&nbsp;</p><p>从上图我们可以知道以下两点：</p><ol><li>当<strong>第一次读取数据的时候</strong>，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；</li><li>当<strong>第二次以及以后需要读取数据时</strong>，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。</li></ol><p>从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。</p><p>分析了读操作的逻辑，下面我们来看看<strong>写操作的流程</strong>：</p><p><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic4.zhimg.com/80/v2-2a22f9f9a052e58f844cd93653f06daf_hd.jpg\"></figure><p><br>&nbsp;</p><p>从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。</p><blockquote><p>关于使用内存存储数据，我知道谷歌好像就是<strong>把所有互联网的数据都存储在内存条</strong>的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌…</p></blockquote><h2>&nbsp;</h2>',17,0,0,0,NULL),(24,15,'<blockquote><p>关于java四种引用类型，我也是刚了解，特此记下！</p></blockquote><p>在Java中提供了四个级别的引用：强引用，软引用，弱引用和虚引用。在这四个引用类型中，只有强引用FinalReference类是包内可见，其他三种引用类型均为public，可以在应用程序中直接使用。引用类型的类结构如图所示。</p><p><br><strong>1.强引用</strong><a href=\"https://www.cnblogs.com/yueshutong/p/9531347.html#1933128797\"><strong>#</strong></a></p><p>Java中的引用，类似C语言中最难的指针。（我是C语言入门编程，指针的概念还是很深入我心。）通过引用，可以对堆中的对象进行操作。如：</p><p>Copy</p><p>StringBuffer stringBuffer = new StringBuffer(\"Helloword\");</p><p>变量str指向StringBuffer实例所在的堆空间，通过str可以操作该对象。<br>&nbsp;</p><figure class=\"image\"><img src=\"https://images2018.cnblogs.com/blog/1136672/201808/1136672-20180824181445637-260253766.png\"></figure><p>强引用的特点：</p><ol><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。</li><li>强引用可能导致内存泄漏。</li></ol><h2><strong>2.软引用</strong><a href=\"https://www.cnblogs.com/yueshutong/p/9531347.html#2604523782\"><strong>#</strong></a></h2><p>软引用是除了强引用外，最强的引用类型。可以通过java.lang.ref.SoftReference使用软引用。一个持有软引用的对象，不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆使用率临近阈值时，才会去回收软引用的对象。因此，软引用可以用于实现对内存敏感的高速缓存。</p><p>SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。一旦垃圾线程回收该Java对象之后，get()方法将返回null。</p><h2><strong>3.弱引用</strong><a href=\"https://www.cnblogs.com/yueshutong/p/9531347.html#1787106800\"><strong>#</strong></a></h2><p>弱引用是一种比软引用较弱的引用类型。在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。在java中，可以用java.lang.ref.WeakReference实例来保存对一个Java对象的弱引用。</p><h2><strong>4.虚引用</strong><a href=\"https://www.cnblogs.com/yueshutong/p/9531347.html#4133157630\"><strong>#</strong></a></h2><p>虚引用是所有类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。</p><p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>',17,0,0,0,NULL);

/*Table structure for table `collection_question_rela_table` */

DROP TABLE IF EXISTS `collection_question_rela_table`;

CREATE TABLE `collection_question_rela_table` (
  `collection_id` bigint(64) NOT NULL,
  `question_id` bigint(64) NOT NULL,
  KEY `collection_id` (`collection_id`),
  KEY `question_id` (`question_id`),
  CONSTRAINT `collection_question_rela_table_ibfk_1` FOREIGN KEY (`collection_id`) REFERENCES `collection_table` (`collection_id`),
  CONSTRAINT `collection_question_rela_table_ibfk_2` FOREIGN KEY (`question_id`) REFERENCES `question_table` (`question_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `collection_question_rela_table` */

/*Table structure for table `collection_table` */

DROP TABLE IF EXISTS `collection_table`;

CREATE TABLE `collection_table` (
  `collection_id` bigint(64) NOT NULL AUTO_INCREMENT,
  `collection_name` varchar(64) NOT NULL,
  `create_time` date NOT NULL,
  `update_time` date NOT NULL,
  `uid` bigint(64) NOT NULL,
  `reserve1` int(11) DEFAULT NULL,
  PRIMARY KEY (`collection_id`),
  KEY `uid` (`uid`),
  CONSTRAINT `collection_table_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `user_table` (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `collection_table` */

/*Table structure for table `comment_table` */

DROP TABLE IF EXISTS `comment_table`;

CREATE TABLE `comment_table` (
  `comm_id` bigint(64) NOT NULL AUTO_INCREMENT,
  `answer_id` bigint(64) NOT NULL,
  `uid` bigint(64) NOT NULL,
  `reply_to_uid` bigint(64) NOT NULL,
  `content` text NOT NULL,
  `agree` bigint(64) DEFAULT '0',
  `reserve1` int(11) DEFAULT NULL,
  PRIMARY KEY (`comm_id`),
  KEY `answer_id` (`answer_id`),
  CONSTRAINT `comment_table_ibfk_1` FOREIGN KEY (`answer_id`) REFERENCES `answer_table` (`answer_id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

/*Data for the table `comment_table` */

insert  into `comment_table`(`comm_id`,`answer_id`,`uid`,`reply_to_uid`,`content`,`agree`,`reserve1`) values (1,5,17,16,'嘿嘿嘿',0,NULL),(2,5,17,16,'测试一次',0,NULL),(3,5,17,16,'测2',0,NULL),(4,8,17,17,'文不对题',0,NULL),(5,23,17,17,'自己顶一下~嘿嘿',0,NULL),(6,18,17,18,'打得真是太好了，感谢大佬~大家都在发',0,NULL),(7,10,17,16,'膜拜大佬~',0,NULL),(8,24,17,17,'新人第一次回答，有点紧张',0,NULL),(9,10,18,16,'java是一门优秀的语言，大佬牛逼，测试评论2019-0807',0,NULL),(10,24,18,17,'水货回答！(°ー°〃)',0,NULL);

/*Table structure for table `follow_rela_table` */

DROP TABLE IF EXISTS `follow_rela_table`;

CREATE TABLE `follow_rela_table` (
  `followed` bigint(64) NOT NULL,
  `follower` bigint(64) NOT NULL,
  KEY `followed` (`followed`),
  KEY `follower` (`follower`),
  CONSTRAINT `follow_rela_table_ibfk_1` FOREIGN KEY (`followed`) REFERENCES `user_table` (`uid`),
  CONSTRAINT `follow_rela_table_ibfk_2` FOREIGN KEY (`follower`) REFERENCES `user_table` (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `follow_rela_table` */

/*Table structure for table `message_table` */

DROP TABLE IF EXISTS `message_table`;

CREATE TABLE `message_table` (
  `message_id` bigint(64) NOT NULL AUTO_INCREMENT,
  `type` int(2) NOT NULL,
  `uid` bigint(64) NOT NULL,
  `from_uid` bigint(64) DEFAULT NULL,
  `question_id` bigint(64) DEFAULT NULL,
  `answer_id` bigint(64) DEFAULT NULL,
  `comment_id` bigint(64) DEFAULT NULL,
  `reserve1` int(11) DEFAULT NULL,
  PRIMARY KEY (`message_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `message_table` */

/*Table structure for table `question_table` */

DROP TABLE IF EXISTS `question_table`;

CREATE TABLE `question_table` (
  `question_id` bigint(64) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) NOT NULL,
  `question_desc` text NOT NULL,
  `uid` bigint(64) NOT NULL,
  `popularity` bigint(64) DEFAULT '0',
  `create_time` date NOT NULL,
  `status` int(1) DEFAULT '1',
  `reserve1` int(11) DEFAULT NULL,
  PRIMARY KEY (`question_id`),
  KEY `uid` (`uid`),
  CONSTRAINT `question_table_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `user_table` (`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8;

/*Data for the table `question_table` */

insert  into `question_table`(`question_id`,`title`,`question_desc`,`uid`,`popularity`,`create_time`,`status`,`reserve1`) values (5,'测试sss','<p>ssss</p><figure class=\"image\"><img src=\"/upload-files/images/ccxkkl).jpg\"></figure>',17,2,'2019-08-02',1,NULL),(6,'测试问题22222','<p>是撒</p><figure class=\"image\"><img src=\"/upload-files/images/dili.jpg\"><figcaption>mayu</figcaption></figure>',17,65,'2019-08-02',1,NULL),(7,'测试数据222','<p>sad是</p><figure class=\"image\"><img src=\"/upload-files/images/sadas).jpg\"><figcaption>lyf</figcaption></figure>',17,32,'2019-08-02',1,NULL),(8,'测试ssss','<figure class=\"image\"><img src=\"/upload-files/images/ccxkkl).jpg\"><figcaption>蔡徐坤</figcaption></figure><p>sad哈哈哈</p><p>&nbsp;</p>',17,66,'2019-08-03',1,NULL),(9,'测试sssss','<figure class=\"image\"><img src=\"/upload-files/images/ccxkkl).jpg\"><figcaption>蔡徐坤</figcaption></figure><p>ikun牛逼</p><p>卢本伟牛逼</p>',17,77,'2019-08-03',1,NULL),(10,'如何看待敬汉卿被知桥电子告知侵权?','<figure class=\"image\"><img src=\"/upload-files/images/jhqwq2.jpeg\"><figcaption>图1</figcaption></figure><p>截图2</p><figure class=\"image\"><img src=\"/upload-files/images/jhqwq1.jpeg\"><figcaption>图2</figcaption></figure><p>截图3</p><figure class=\"image\"><img src=\"/upload-files/images/jhqwq3.png\"><figcaption>图3</figcaption></figure>',17,381,'2019-08-04',1,NULL),(11,'The difference between resulttype and resultMap','<figure class=\"image\"><img src=\"/upload-files/images/pika.jpg\"></figure>',16,55,'2019-08-05',1,NULL),(12,'What is the builder pattern?','<p>简单的设计模式</p>',16,91,'2019-08-05',1,NULL),(13,'什么是适配器模式','<p>简单的设计模式</p>',16,517,'2019-08-05',1,NULL),(14,'网恋教父在线教学','<p>完美融入各种心理学课程，让你的女神欲仙欲死</p>',16,340,'2019-08-05',1,NULL),(15,'Java引用类型','<p>引用类型的种类</p>',16,17,'2019-08-05',1,NULL),(16,'GET 和POST之间的区别','<p>http请求方式</p>',16,211,'2019-08-05',1,NULL),(17,'分页语句','<p>MySQL</p>',16,1,'2019-08-05',1,NULL),(18,'XML','<p>XML有哪些解析技术，各有什么分别</p>',16,1,'2019-08-05',1,NULL),(19,'Spring 的依赖注入','',16,82,'2019-08-05',1,NULL),(20,'JDO是什么','',16,211,'2019-08-05',1,NULL),(21,'SpringMvc的执行流程','<figure class=\"image\"><img src=\"/upload-files/images/Grady.jpg\"></figure>',16,115,'2019-08-05',1,NULL),(22,'为什么五五开辣么牛批？','<p>五五开为什么要给阿姨一杯卡布奇诺</p><figure class=\"image\"><img src=\"/upload-files/images/微信图片_20190723160306.jpg\"></figure>',18,37,'2019-08-06',1,NULL),(23,'租不隔音的房子有什么体验？','<h2>租不隔音计算机 租不隔音的房子有什么体验？的房子有什么体验？</h2>',18,22,'2019-08-06',1,NULL),(24,'网易Java岗30道Redis面试题详解','<h2>网易Java岗30道Redis面试题详解</h2>',18,510,'2019-08-06',1,NULL),(25,'[灵魂拷问]MySQL面试高频一百问(工程师方向)','<h2>前言</h2><p><br>&nbsp;</p><p>本文主要受众为开发人员,所以不涉及到MySQL的服务部署等操作,且内容较多,大家准备好耐心和瓜子矿泉水.</p><p><br>前一阵系统的学习了一下MySQL,也有一些实际操作经验,偶然看到一篇和MySQL相关的面试文章,发现其中的一些问题自己也回答不好,虽然知识点大部分都知道,但是无法将知识串联起来.</p><p><br>因此决定搞一个MySQL灵魂100问,试着用回答问题的方式,让自己对知识点的理解更加深入一点.</p><h2>索引相关</h2><p><br><strong>1. 什么是索引?</strong><br>索引是一种数据结构,可以帮助我们快速的进行数据的查找.</p><p><br><strong>2. 索引是个什么样的数据结构呢?</strong></p><p><br>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.</p><p><br><strong>3. Hash索引和B+树所有有什么区别或者说优劣呢?</strong></p><p><br>首先要知道Hash索引和B+树索引的底层实现原理:</p><p><br>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.<br>那么可以看出他们有以下的不同:<br>&nbsp;</p><ul><li>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</li></ul><p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.<br>&nbsp;</p><ul><li>hash索引不支持使用索引进行排序,原理同上.<br>&nbsp;</li><li>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.<strong>AAAA</strong>和<strong>AAAAB</strong>的索引没有相关性.<br>&nbsp;</li><li>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.<br>&nbsp;</li><li>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.<br>&nbsp;</li></ul><p>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</p><p><br><strong>4. 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?</strong></p><p><br>在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.</p><p><br>当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.</p><p><br><strong>5. 非聚簇索引一定会回表查询吗?</strong></p><p><br>不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.</p><p>举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age &lt; 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.</p><p><br><strong>6. 在建立索引的时候,都有哪些需要考虑的因素呢?</strong></p><p><br>建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.</p><p><br><strong>7. 联合索引是什么?为什么需要注意联合索引中的顺序?</strong></p><p><br>MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.<br>具体原因为:</p><p><br>MySQL使用索引时需要索引有序,假设现在建立了\"name,age,school\"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.</p><p><br>当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.</p><p><br><strong>8. 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?</strong></p><p><br>MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.</p><p><br><strong>9. 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?</strong><br>&nbsp;</p><ul><li>使用不等于查询,</li><li>列参与了数学运算或者函数</li><li>在字符串like时左边是通配符.类似于\'%aaa\'.</li><li>当mysql分析全表扫描比使用索引快的时候不使用索引.</li><li>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.</li></ul><p>以上情况,MySQL无法使用索引.</p><h2><br>事务相关</h2><p><br><strong>1. 什么是事务?</strong></p><p><br>理解什么是事务最经典的就是转账的栗子,相信大家也都了解,这里就不再说一边了.<br>事务是一系列的操作,他们要符合ACID特性.最常见的理解就是:事务中的操作要么全部成功,要么全部失败.但是只是这样还不够的.</p><p><br><strong>2. ACID是什么?可以详细说一下吗?</strong></p><p><br>A=Atomicity<br>原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.<br>C=Consistency<br>系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.<br>I=Isolation<br>隔离性: 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.<br>D=Durability<br>持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.</p><p><br><strong>3. 同时有多个事务在进行会怎么样呢?</strong></p><p><br>多事务的并发进行一般会造成以下几个问题:<br>&nbsp;</p><ul><li>脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.</li><li>不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.</li><li>幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成\"幻觉\".</li></ul><p><strong>4. 怎么解决这些问题呢?MySQL的事务隔离级别了解吗?</strong></p><p><br>MySQL的四种隔离级别如下:<br>&nbsp;</p><ul><li>未提交读(READ UNCOMMITTED)</li></ul><p>这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).<br>这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.<br>&nbsp;</p><ul><li>已提交读(READ COMMITTED)</li></ul><p>其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.<br>&nbsp;</p><ul><li>REPEATABLE READ(可重复读)</li></ul><p>可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取id&gt; 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.<br>&nbsp;</p><ul><li>SERIALIZABLE(可串行化)</li></ul><p>这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.</p><p><br><strong>5. Innodb使用的是哪种隔离级别呢?</strong></p><p><br>InnoDB默认使用的是可重复读隔离级别.</p><p><br><strong>6. 对MySQL的锁了解吗?</strong></p><p><br>当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.<br>就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.</p><p><br><strong>7. MySQL都有哪些锁呢?像上面那样子进行锁定岂不是有点阻碍并发效率了?</strong></p><p><br>从锁的类别上来讲,有共享锁和排他锁.<br>共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.<br>排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.<br>用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.<br>锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.<br>他们的加锁开销从大大小,并发能力也是从大到小.</p><h2><br>表结构设计</h2><p><br><strong>1. 为什么要尽量设定一个主键?</strong></p><p><br>主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.</p><p><br><strong>2. 主键使用自增ID还是UUID?</strong></p><p><br>推荐使用自增ID,不要使用UUID.<br>因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.<br>总之,在数据量大一些的情况下,用自增主键性能会好一些.<br><i>图片来源于《高性能MySQL》: 其中默认后缀为使用自增ID,_uuid为使用UUID为主键的测试,测试了插入100w行和300w行的性能.</i><br><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic4.zhimg.com/80/v2-c428528b5f35720c9f88bba5e558c337_hd.jpg\"></figure><p><br>关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.</p><p>If you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index.</p><p><br>&nbsp;</p><p>NULL columns require additional space in the rowto record whether their values \nare NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up \nto the nearest byte.</p><p>null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.</p><p><br><strong>4. 如果要存储用户的密码散列,应该使用什么字段进行存储?</strong></p><p><br>密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率.</p><h2><br>存储引擎相关</h2><p><br><strong>1. MySQL支持哪些存储引擎?</strong></p><p><br>MySQL支持多种存储引擎,比如InnoDB,MyISAM,Memory,Archive等等.在大多数的情况下,直接选择使用InnoDB引擎都是最合适的,InnoDB也是MySQL的默认存储引擎.<br>&nbsp;</p><ol><li>InnoDB和MyISAM有什么区别?</li></ol><ul><li>InnoDB支持事物，而MyISAM不支持事物</li><li>InnoDB支持行级锁，而MyISAM支持表级锁</li><li>InnoDB支持MVCC, 而MyISAM不支持</li><li>InnoDB支持外键，而MyISAM不支持</li><li>InnoDB不支持全文索引，而MyISAM支持。</li></ul><h2>零散问题</h2><p><br><strong>1. MySQL中的varchar和char有什么区别.</strong></p><p><br>char是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用10个字符,而varchar是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.</p><p><br>在检索效率上来讲,char &gt; varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则应该尽量使用varchar.例如存储用户MD5加密后的密码,则应该使用char.</p><p><br><strong>2. varchar(10)和int(10)代表什么含义?</strong></p><p><br>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.</p><p><br><strong>3. MySQL的binlog有有几种录入格式?分别有什么区别?</strong></p><p><br>有三种格式,statement,row和mixed.<br>&nbsp;</p><ul><li>statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.</li><li>row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.</li><li>mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.</li></ul><p>此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.</p><p><br><strong>4. 超大分页怎么处理?</strong></p><p><br>超大的分页一般从两个方向上来解决.<br>&nbsp;</p><ul><li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li><li>从需求的角度减少这种请求....主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p><br>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.<br><br>&nbsp;</p><figure class=\"image\"><img src=\"https://pic3.zhimg.com/80/v2-a4e30f3ce60ec68cc3b856a17ea67bbe_hd.jpg\"></figure><p><br><strong>5. 关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?</strong></p><p><br>在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.</p><p><br>慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?</p><p><br>所以优化也是针对这三个方向来的,<br>&nbsp;</p><ul><li>首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.<br>&nbsp;</li><li>分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.<br>&nbsp;</li><li>如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.<br>&nbsp;</li></ul><p><strong>6. 上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗?</strong></p><p><br>横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的. 假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.</p><p><br>纵向分表是按列分表.假设我们现在有一张文章表.包含字段id-摘要-内容.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要,当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.我们可以将上面的表分为两张.id-摘要,id-内容.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.</p><p><br>当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.</p><p><br><strong>7. 什么是存储过程？有哪些优缺点？</strong></p><p><br>存储过程是一些预编译的SQL语句。 1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</p><p><br>但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.</p><p><br><strong>8. 说一说三个范式</strong></p><p><br>第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.</p><p><br>在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.</p><p><br><strong>9. MyBatis中的#和$有什么区别?</strong></p><p><br>乱入了一个奇怪的问题.....我只是想单独记录一下这个问题,因为出现频率太高了.<br># 会将传入的内容当做字符串,而$会直接将传入值拼接在sql语句中.<br>所以#可以在一定程度上预防sql注入攻击.</p>',18,460,'2019-08-06',1,NULL),(26,'Spring Session工作原理','<h2>Spring Session工作原理</h2>',18,370,'2019-08-06',1,NULL),(27,'死磕Synchronized底层实现，面试你还怕什么？','<h2>死磕Synchronized底层实现，面试你还怕什么？</h2>',18,132,'2019-08-06',1,NULL),(28,'史上最全Java面试题（带全部答案）','<h2>史上最全Java面试题（带全部答案）</h2>',18,97,'2019-08-06',1,NULL),(33,'python如何画出这样漂亮的地图？','<p>125 人赞同了该回答</p><p>推荐一个超好用的python包<a href=\"https://link.zhihu.com/?target=https%3A//pypi.org/project/folium/\">folium</a>, 专门用于<strong>地理数据可视化</strong>，官方英文教程教程<a href=\"https://link.zhihu.com/?target=https%3A//python-visualization.github.io/folium/quickstart.html\">点击这里</a>。</p><figure class=\"image\"><img src=\"https://pic2.zhimg.com/80/v2-4ec6f4738108ddafa4a2e949b64017e7_hd.jpg\"></figure><p>使用方法很简单，操作如下：</p><ol><li>导入包，创建一副世界地图</li></ol><p>import folium\n\n# define the world map\nworld_map = folium.Map()\n\n# display world map\nworld_map</p><figure class=\"image\"><img src=\"https://pic2.zhimg.com/80/v2-5d713f1d7842f791401de32777ef3cc5_hd.jpg\"></figure><p>感谢</p><p><a href=\"https://www.zhihu.com/people/85df9dddd56d4056a6cdc045208bce66\">@螺旋真理</a></p><p>指出关于中国藏南边界的问题，为避免误导读者，我已更新图片显示。folium包是基于OpenStreetMap地图服务，OpenStreetMap是非赢利性机构（如同维基百科，内容来自用户的个人贡献），其将藏南地区划入了印度、阿克赛钦地区划入了中国。而Google Maps和Bing Maps，它们在中国版本中将争议地区划入中国，印度版本中将争议地区划入印度。如有其他疑问请参考下述链接:</p><p>&nbsp;</p><p><a href=\"https://link.zhihu.com/?target=http%3A//bbs.creaders.net/life/bbsviewer.php%3Ftrd_id%3D897674\">看几大 Online Maps 如何标注中印边界​bbs.creaders.net</a></p><p>&nbsp;</p><p><br>&nbsp;</p><p>2. 输入经纬度，尺度，在这里我们以旧金山（37.7749° N, 122.4194° W）为例。</p><p># San Francisco latitude and longitude values\nlatitude = 37.77\nlongitude = -122.42\n\n# Create map and display it\nsan_map = folium.Map(location=[latitude, longitude], zoom_start=12)\n\n# Display the map of San Francisco\nsan_map</p><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-dd61da9ec500b3bc6f160c2f89668137_hd.jpg\"></figure><p>更改地图显示，默认为\'OpenStreetMap\'风格，我们还可以选择\'Stamen Terrain\', \'Stamen Toner\'等。</p><p># Create map and display it\nsan_map = folium.Map(location=[latitude, longitude], zoom_start=12,tiles=\'Stamen Toner\')</p><figure class=\"image\"><img src=\"https://pic2.zhimg.com/80/v2-1cdba09f564d4df95512fdcd697ca76a_hd.jpg\"></figure><p>3. 读取数据集（旧金山犯罪数据集）</p><p># Read Dataset \ncdata = pd.read_csv(\'https://cocl.us/sanfran_crime_dataset\')\ncdata.head()</p><figure class=\"image\"><img src=\"https://pic1.zhimg.com/80/v2-68751ecb623db1270dcc66f5a372bb4e_hd.jpg\"></figure>',17,390,'2019-08-06',1,NULL);

/*Table structure for table `topic_question_rela_table` */

DROP TABLE IF EXISTS `topic_question_rela_table`;

CREATE TABLE `topic_question_rela_table` (
  `topic_id` bigint(64) NOT NULL,
  `question_id` bigint(64) NOT NULL,
  KEY `topic_id` (`topic_id`),
  KEY `question_id` (`question_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `topic_question_rela_table` */

insert  into `topic_question_rela_table`(`topic_id`,`question_id`) values (2,7),(3,7),(4,8),(4,9),(5,10),(4,10),(17,11),(17,12),(17,13),(8,14),(17,15),(17,16),(17,17),(14,18),(17,19),(17,20),(17,21),(8,22),(14,22),(14,24),(14,25),(14,26),(14,27),(14,28),(14,33),(8,33);

/*Table structure for table `topic_table` */

DROP TABLE IF EXISTS `topic_table`;

CREATE TABLE `topic_table` (
  `topic_id` bigint(64) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) NOT NULL,
  `avatar` varchar(64) DEFAULT 'image/dft1.jpg',
  `topic_desc` varchar(512) NOT NULL,
  `father_topic` bigint(64) NOT NULL,
  `popularity` bigint(64) DEFAULT '0',
  `create_time` date NOT NULL,
  `reserve1` int(11) DEFAULT NULL,
  `reserve2` int(11) DEFAULT NULL,
  PRIMARY KEY (`topic_id`)
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;

/*Data for the table `topic_table` */

insert  into `topic_table`(`topic_id`,`name`,`avatar`,`topic_desc`,`father_topic`,`popularity`,`create_time`,`reserve1`,`reserve2`) values (1,'根话题','image/dft1.jpg','是话题树的根节点，所有话题继承根话题',0,0,'2019-07-30',NULL,NULL),(2,'自然科学','image/topic-natureS.jpg','它是以定量作为手段，研究无机自然界和包括人的生物属性在内的有机自然界的各门科学的总称。',1,0,'2019-07-30',NULL,NULL),(3,'形式科学','image/topic-formalS.jpg','形式科学 是与形式系统，如逻辑学、数学、理论计算机科学、信息理论、系统理论、判定理论、统计学和一些语义学等有关的知识的分支。和其它科学不同，形式科学不是和基于真实世界观察理论有效性联系的。',1,0,'2019-07-30',NULL,NULL),(4,'人文社会科学','image/topic-hum&socScience.jpg','人文科学，是以人类的精神世界及其沉淀的精神文化为对象的科学。社会科学则是一种以人类社会为研究对象的科学。如果说人文科学主要研究人的观念、精神、情感和价值，即人的主观精神世界及其所积淀下来的精神文化的话，那么社会科学更多地则是研究客观的人类社会而外在于具体的个人及其主观世界。前者常用意义分析和解释学的方法研究微观领域的精神文化现象，其涵覆的科学包括文、史、哲及其衍生出来的美学、宗教学、伦理学、文化学、艺术学等。',1,0,'2019-07-30',NULL,NULL),(5,'生活','image/topic-life.jpg','广义上指人的各种活动，包括日常生活行为、学习、工作、休闲、社交、娱乐等。',1,0,'2019-07-30',NULL,NULL),(6,'逻辑学','image/topic-logic.jpg','逻辑学是研究思维的学科。所有思维都有内容和形式两个方面。思维内容是指思维所反映的对象及其属性；思维形式是指用以反映对象及其属性的不同方式，即表达思维内容的不同方式。从逻辑学角度看，抽象思维的三种基本形式是概念，命题和推理。',3,0,'2019-07-30',NULL,NULL),(7,'数学','image/topic-math.jpg','是研究数量、结构、变化、空间以及信息等概念的一门学科，从某种角度看属于形式科学的一种。',3,0,'2019-07-30',NULL,NULL),(8,'计算机科学','image/computerScience.jpg','计算机科学（英语：computer science，有时缩写为CS）是系统性研究信息与计算的理论基础以及它们在计算机系统中如何实现与应用的实用技术的学科。',3,0,'2019-07-30',NULL,NULL),(9,'计算理论','image/dft1.jpg','计算理论 【theory of computation】 用来研究计算的过程与功效的数学理论。',8,0,'2019-07-30',NULL,NULL),(10,'信息论','image/dft1.jpg','信息论是运用概率论与数理统计的方法研究信息、信息熵、通信系统、数据传输、密码学、数据压缩等问题的应用数学学科。',8,0,'2019-07-30',NULL,NULL),(11,'数据库和信息检索','image/topic-database.jpg','数据库是为了更容易地组织、存储和检索大量数据。数据库由数据库管理系统管理，通过数据库模型和查询语言来存储、创建、维护和搜索数据。',8,0,'2019-07-30',NULL,NULL),(12,'人工智能','image/topic-AI.jpg','这个计算机科学分支旨在创造可以解决计算问题，以及像动物和人类一样思考与交流的人造系统。',8,0,'2019-07-30',NULL,NULL),(13,'软件工程','image/dft1.jpg','软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的计算机软件的学科。',8,0,'2019-07-30',NULL,NULL),(14,'计算机语言','image/topic-prog.jpg','计算机语言（Computer Language）指用于人与计算机之间通讯的语言。计算机语言是人与计算机之间传递信息的媒介。计算机系统最大特征是指令通过一种语言传达给机器。为了使电子计算机进行各种工作，就需要有一套用以编写计算机程序的数字、字符和语法规划，由这些字符和语法规则组成计算机各种指令（或各种语句）。这些就是计算机能接受的语言。',8,0,'2019-07-30',NULL,NULL),(15,'面向过程编程','image/dft1.jpg','面向过程(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，',14,0,'2019-07-30',NULL,NULL),(16,'面向对象编程','image/dft1.jpg','面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术 [1]  发展到一定阶段后的产物。',14,0,'2019-07-30',NULL,NULL),(17,'Java','image/topic-java.jpg','Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程',14,0,'2019-07-30',NULL,NULL),(18,'C++','image/topic-c++.jpg','C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。',14,0,'2019-07-30',NULL,NULL);

/*Table structure for table `topic_user_rela_table` */

DROP TABLE IF EXISTS `topic_user_rela_table`;

CREATE TABLE `topic_user_rela_table` (
  `topic_id` bigint(64) NOT NULL,
  `uid` bigint(64) NOT NULL,
  KEY `topic_id` (`topic_id`),
  KEY `uid` (`uid`),
  CONSTRAINT `topic_user_rela_table_ibfk_1` FOREIGN KEY (`topic_id`) REFERENCES `topic_table` (`topic_id`),
  CONSTRAINT `topic_user_rela_table_ibfk_2` FOREIGN KEY (`uid`) REFERENCES `user_table` (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `topic_user_rela_table` */

/*Table structure for table `user_table` */

DROP TABLE IF EXISTS `user_table`;

CREATE TABLE `user_table` (
  `uid` bigint(64) NOT NULL AUTO_INCREMENT,
  `email` varchar(64) NOT NULL,
  `password` varchar(32) NOT NULL,
  `username` varchar(32) NOT NULL,
  `status` int(1) NOT NULL DEFAULT '1',
  `join_time` date NOT NULL,
  `gender` int(1) DEFAULT NULL,
  `phone` char(11) DEFAULT NULL,
  `avatar` varchar(64) DEFAULT NULL,
  `intro` varchar(256) DEFAULT NULL,
  `industry` varchar(32) DEFAULT NULL,
  `education` text,
  `liked_count` bigint(64) DEFAULT '0',
  `follow_count` bigint(64) DEFAULT '0',
  `follower_count` bigint(64) DEFAULT '0',
  `scan_count` bigint(64) DEFAULT '0',
  `score` int(32) DEFAULT '0',
  `reserve1` int(11) DEFAULT NULL,
  `reserve2` int(11) DEFAULT NULL,
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;

/*Data for the table `user_table` */

insert  into `user_table`(`uid`,`email`,`password`,`username`,`status`,`join_time`,`gender`,`phone`,`avatar`,`intro`,`industry`,`education`,`liked_count`,`follow_count`,`follower_count`,`scan_count`,`score`,`reserve1`,`reserve2`) values (1,'test@163.com','123456','测试账号',1,'2019-05-15',1,'15111111111','keming_xu@163.com_avatar.jpg','无','化工燃料','浙江大学',0,0,0,0,0,NULL,NULL),(16,'Grady330@163.com','123456','terry',1,'2019-07-30',1,NULL,'mayun.jpg',NULL,'化工燃料/航空航天',NULL,0,0,0,0,0,NULL,NULL),(17,'keming_xu@163.com','123456','胥珂铭',1,'2019-07-31',0,'15111422198','u=4051517536,4282666414&fm=26&gp=0.jpg',NULL,'化工/医疗/互联网软件','长沙搬砖大学',0,0,0,0,0,NULL,NULL),(18,'doudoow@163.com','1314520','余冰',1,'2019-08-06',0,'17608419956','cxkcxkavatar.jpg',NULL,'电气工程/通信/信号处理','麻省理工(MIT)-电气工程硕士',0,0,0,0,0,NULL,NULL);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
